C UTEP Electronic Structure Lab (2020)
C
C *****************************************************************
C
C FILLIST FILLS AN INTERSTITIAL BOX WITH MESH POINTS
C ATTENTION: PARAMETERS AND COMMON/TMP1/ MUST BE IDENTICAL TO IS1DIM
C
       SUBROUTINE FILLIST(BOXIN,ERRBOX,NMULT)

        use mesh1,only : wmsh,rmsh,nmsh
        use xtmp3,only : MAXTST,MAXNP,ALTAB,PREFAC,RTST,
     &     XYZWGT,CORRECT,YZDECAY,SUMMESH,
     &     TABINT,TABSUM,TABNRM,NPTAB,NTST

       use common3,only : RMAT, NGRP
       use istitl
! Conversion to implicit none.  Raja Zope Sun Aug 20 09:01:49 MDT 2017

!      INCLUDE  'PARAMAS'  
       INCLUDE  'PARAMA2'  
       INTEGER :: NMULT, MXBOXT, IALP, IBOX, IC, ICNT, IERR, IFAC,
     & IGRP, INUC, IPOW, IPTS, IR, IX, IY, IZ, J, JBOX, JPTS, K,
     & KPTS, MAXP1D, MAXTS, NALP, NBOX, NNBOX, NNEW, NNMSH, 
     & NPWR, NSAV, NXPT
       REAL*8 :: SYMBOL , BOXIN, ERRBOX, ALFAC, ALMAX, ALMIN,
     & ALP, ALPRC, ALRC2, ATMP, BOXTAB, DD, DIF, DIST, ERRNOW,
     & PI, POTF, RCOF, RHOF, RREF, RSQR, RTMP, RXPT, SDIST,
     & TOLER, TWEIG, VWGT, W, WXPT, X1, X2, XCUT, ZER
        REAL*8 :: RCUTOFF, ALCUTOFF
        SAVE
        PARAMETER (MXBOXT=500)
        PARAMETER (MAXP1D=20)
C        PARAMETER (MAXTST=2000)
C        PARAMETER (MAXNP=6)
        DIMENSION BOXIN(2,3)
!        COMMON/ISTITL/RNUC(3,MX_CNT),ZALP(2,MX_CNT),AFUDIS,ALONG
!     &   ,IFNU(MX_CNT),NPOW(MX_CNT),NNUC,MX1D
C        COMMON/TMP1/ALTAB(MAXTST),PREFAC(0:MAXNP,MAXTST),RTST(3,MAXTST)
C     &   ,XYZWGT(0:MAXNP,3,MAXTST),CORRECT(0:MAXNP,3,MAXTST)
C     &   ,YZDECAY(0:MAXNP,MAXTST),SUMMESH(0:MAXNP,MAXTST)
C     &   ,TABINT(0:MAXNP,3),TABSUM(0:MAXNP,3),TABNRM(0:MAXNP)
C     &   ,NPTAB(MAXTST),NTST
        LOGICAL OK,OKTOT
        DIMENSION BOXTAB(2,3,MXBOXT),RSQR(MAXP1D*MAXP1D*MAXP1D)
        DIMENSION RXPT(MAXP1D,3),WXPT(MAXP1D,3),XCUT(3,3)
        DIMENSION NNEW(3),NXPT(3),IR(3)
        DATA PI/3.14159265358979323844D0/
        DATA TOLER/1.0D-8/
C        REAL*8,ALLOCATABLE :: ALTAB(:),PREFAC(:,:),RTST(:,:),
C     &     XYZWGT(:,:,:),CORRECT(:,:,:),YZDECAY(:,:),SUMMESH(:,:),
C     &     TABINT(:,:),TABSUM(:,:),TABNRM(:)
C        INTEGER,ALLOCATABLE :: NPTAB(:)
C        INTEGER :: NTST
C
C ALLOCATE LOCAL ARRAYS
C
        ALLOCATE(ALTAB(MAXTST),STAT=IERR)
        IF(IERR.NE.0) WRITE(6,*)'FILLIST:ERROR ALLOCATING ALTAB'
        ALLOCATE(PREFAC(0:MAXNP,MAXTST),STAT=IERR)
        IF(IERR.NE.0) WRITE(6,*)'FILLIST:ERROR ALLOCATING PREFAC'
        ALLOCATE(RTST(3,MAXTST),STAT=IERR)
        IF(IERR.NE.0) WRITE(6,*)'FILLIST:ERROR ALLOCATING RTST'
        ALLOCATE(XYZWGT(0:MAXNP,3,MAXTST),STAT=IERR)
        IF(IERR.NE.0) WRITE(6,*)'FILLIST:ERROR ALLOCATING XYZWGT'
        ALLOCATE(CORRECT(0:MAXNP,3,MAXTST),STAT=IERR)
        IF(IERR.NE.0) WRITE(6,*)'FILLIST:ERROR ALLOCATING CORRECT'
        ALLOCATE(YZDECAY(0:MAXNP,MAXTST),STAT=IERR)
        IF(IERR.NE.0) WRITE(6,*)'FILLIST:ERROR ALLOCATING YZDECAY'
        ALLOCATE(SUMMESH(0:MAXNP,MAXTST),STAT=IERR)
        IF(IERR.NE.0) WRITE(6,*)'FILLIST:ERROR ALLOCATING SUMMESH'
        ALLOCATE(TABINT(0:MAXNP,3),STAT=IERR)
        IF(IERR.NE.0) WRITE(6,*)'FILLIST:ERROR ALLOCATING TABINT'
        ALLOCATE(TABSUM(0:MAXNP,3),STAT=IERR)
        IF(IERR.NE.0) WRITE(6,*)'FILLIST:ERROR ALLOCATING TABSUM'
        ALLOCATE(TABNRM(0:MAXNP),STAT=IERR)
        IF(IERR.NE.0) WRITE(6,*)'FILLIST:ERROR ALLOCATING TABNRM'
        ALLOCATE(NPTAB(MAXTST),STAT=IERR)
        IF(IERR.NE.0) WRITE(6,*)'FILLIST:ERROR ALLOCATING NPTAB'
C
C CHECK MX1D, AFUDIS
C         
        IF (NMULT .LE. 0) RETURN
        IF (MX1D .LT. 1) THEN
         write(6,*)'FILLIST: MAX. NUMBER OF POINTS IN A 1-DIMENSIONAL'
         write(6,*)'INTERSTITIAL REGION MUST BE AT LEAST 1'
         CALL STOPIT
        END IF
        IF (MX1D .GT. MAXP1D) THEN
         write(6,*)'FILLIST: MAXP1D MUST BE AT LEAST: ',MX1D
         CALL STOPIT
        END IF
        IF (AFUDIS .LT. 1.01D0) AFUDIS=1.01D0
C
C CHECK NPOW
C
        DO ICNT=1,NNUC
         IF (NPOW(ICNT) .GT. MAXNP) THEN
          write(6,*)'FILLIST: NPOW > MAXNP'
          CALL STOPIT
         END IF
         IF (NPOW(ICNT) .LT. 0) THEN
          write(6,*)'FILLIST: NPOW < 0'
          CALL STOPIT
         END IF
        END DO  
C
C SETUP FOR FIRST BOX
C
        DO IC=1,3
         BOXTAB(1,IC,1)= BOXIN(1,IC)
         BOXTAB(2,IC,1)= BOXIN(2,IC)
        END DO
        NBOX=1
C
C SPLIT BOXES UNTIL WE HAVE SUCCESS
C
        IBOX=0
   10   CONTINUE
         IBOX=IBOX+1
C
C FOR EACH ATOM, FIND DISTANCE TO BOX AND CORRESPONDING ATOMIC POTENTIAL
C CORRECT ERRNOW IF NECESSARY
C
         VWGT= 0.0D0
         DO INUC=1,NNUC
          DIST= 0.0D0
          DO IC=1,3
           IF (RNUC(IC,INUC) .LT. BOXTAB(1,IC,IBOX)) THEN
            DIST= DIST+(RNUC(IC,INUC)-BOXTAB(1,IC,IBOX))**2
           END IF
           IF (RNUC(IC,INUC) .GT. BOXTAB(2,IC,IBOX)) THEN
            DIST= DIST+(RNUC(IC,INUC)-BOXTAB(2,IC,IBOX))**2
           END IF
          END DO
          SDIST= SQRT(DIST)
          CALL RPFIT(IFNU(INUC),SDIST,1.0D0/SDIST,RHOF,POTF)
          VWGT= MAX(VWGT,ABS(POTF))
         END DO
         ERRNOW= ERRBOX/MAX(1.0D0,VWGT)
C
C BUILD LIST OF ATOMS RELEVANT FOR THIS CUBE
C
         NTST=0
         DO 100 ICNT=1,NNUC
          ALMIN=ZALP(1,ICNT)+ALONG
          DD=0.0D0
          DO IC=1,3
           RREF=RNUC(IC,ICNT)
           X1=BOXTAB(1,IC,IBOX)
           X2=BOXTAB(2,IC,IBOX)
           IF (RNUC(IC,ICNT) .LE. X1) RREF=X1
           IF (RNUC(IC,ICNT) .GE. X2) RREF=X2
           DD=DD+(RNUC(IC,ICNT)-RREF)**2
          END DO
          RCOF=RCUTOFF(NPOW(ICNT)+2,ALMIN,ERRNOW)
C
C IF THE ATOM IS CLOSE ENOUGH, DO MORE SOPHISTICATED CHECK
C
          IF (DD .LE. RCOF*RCOF) THEN
           ALMAX=ALCUTOFF(NPOW(ICNT)+2,DD,ERRNOW)
           ALMAX=MIN(ALMAX,ZALP(2,ICNT))
           IF (ALMIN .GE. ALMAX) THEN
            NALP=1
            ALFAC=1.0D0
           ELSE
            NALP=2+INT(LOG(ALMAX/ALMIN)/LOG(AFUDIS))
            ATMP=NALP-1
            ALFAC=(ALMAX/ALMIN)**(1.0D0/ATMP)
           END IF
C
C FOR EACH DIRECTION AND ALPHA, CALCULATE EXACT INTEGRAL
C AND EXACT ABSOLUTE INTEGRAL
C CHECK HOW BIG INTEGRAL OVER BOX IS COMPARED TO INTEGRAL OVER ALL SPACE
C
           ALP=ALMIN
           NPWR=NPOW(ICNT)
           DO 80 IALP=1,NALP
            ALPRC=1.0D0/ALP
            ALRC2=0.5D0*ALPRC
            TABNRM(0)=SQRT(PI*ALPRC)
            IF (NPWR .GE. 1) TABNRM(1)=ALPRC
            DO IPOW=2,NPWR
             TABNRM(IPOW)=TABNRM(IPOW-2)*(IPOW-1)*ALRC2
            END DO
            DO IPOW=0,NPWR
             TABNRM(IPOW)=1.0D0/TABNRM(IPOW)
            END DO
            TWEIG=1.0D0
            DO 30 IC=1,3
             X1=BOXTAB(1,IC,IBOX)-RNUC(IC,ICNT)
             X2=BOXTAB(2,IC,IBOX)-RNUC(IC,ICNT)
             ZER=0.0D0
             IF (X1 .GE. ZER) THEN
              CALL G1DINT( X1, X2,NPWR,ALP,TABINT(0,IC))
              DO IPOW=0,NPWR
               TABSUM(IPOW,IC)=TABINT(IPOW,IC)
              END DO
             ELSE IF (X2 .LE. ZER) THEN
              CALL G1DINT(-X2,-X1,NPWR,ALP,TABINT(0,IC))
              IFAC=1
              DO IPOW=0,NPWR
               TABSUM(IPOW,IC)= IFAC*TABINT(IPOW,IC)
               IFAC= -IFAC
              END DO
             ELSE
              CALL G1DINT(ZER, X2,NPWR,ALP,TABINT(0,IC))
              CALL G1DINT(ZER,-X1,NPWR,ALP,TABSUM(0,IC))
              IFAC=1
              DO IPOW=0,NPWR
               TABINT(IPOW,IC)=TABINT(IPOW,IC)+TABSUM(IPOW,IC)
               TABSUM(IPOW,IC)=TABINT(IPOW,IC)+(IFAC-1)*TABSUM(IPOW,IC)
               IFAC= -IFAC
              END DO
             END IF
             W=0.0D0
             DO IPOW=0,NPWR
              W=MAX(W,TABINT(IPOW,IC)*TABNRM(IPOW))
             END DO
             TWEIG=TWEIG*W
   30       CONTINUE
C
C IF TWEIG IS LARGER THAN ERRNOW, ADD TO LIST
C
            IF (TWEIG .GT. ERRNOW) THEN
             NTST=NTST+1
             IF (NTST .GT. MAXTST) THEN
              write(6,*)'FILLIST: PARAMETER MAXTST IS CURRENTLY: ',MAXTST
              write(6,*)'         MUST BE SUBSTANTIALLY LARGER'
             END IF
             ALTAB(NTST)=ALP
             NPTAB(NTST)=NPWR
             DO IPOW=0,NPWR
              PREFAC(IPOW,NTST)=TABNRM(IPOW)
             END DO
             DO IC=1,3
              RTST(IC,NTST)=RNUC(IC,ICNT)
              DO IPOW=0,NPWR
               XYZWGT (IPOW,IC,NTST)=TABINT(IPOW,IC)
               CORRECT(IPOW,IC,NTST)=TABSUM(IPOW,IC)
              END DO
             END DO
            END IF
C
C NEXT EXPONENT
C
            ALP=ALP*ALFAC
   80      CONTINUE
          END IF
  100    CONTINUE
         IF (NTST .LE. 0) GOTO 200
C
C DONE BULIDING INTEGRAL TABLES, NOW FIND APPROPRIATE 1-D MESHES
C
         OKTOT= .TRUE.
         DO IC=1,3
          CALL IS1DIM(ERRNOW,BOXTAB(1,1,IBOX),IC,RXPT(1,IC),WXPT(1,IC),
     &                NXPT(IC),OK)
          XCUT(1,IC)=BOXTAB(1,IC,IBOX)
          IF (OK) THEN
           NNEW(IC)=1
           XCUT(2,IC)=BOXTAB(2,IC,IBOX)
          ELSE
           OKTOT= .FALSE.
           NNEW(IC)= 2
           XCUT(2,IC)=0.5D0*(BOXTAB(1,IC,IBOX)+BOXTAB(2,IC,IBOX))
           XCUT(3,IC)=BOXTAB(2,IC,IBOX)
          END IF
         END DO
C
C PARTITION CUBE IF UNSUCCESSFUL MESH
C
         IF (.NOT. OKTOT) THEN
          NNBOX=NBOX+NNEW(1)*NNEW(2)*NNEW(3)
          IF (NNBOX .GT. MXBOXT) THEN
           write(6,*)'FILLIST: MXBOXT MUST BE AT LEAST: ',NNBOX
           CALL STOPIT
          END IF
          JBOX=NBOX
          DO IX=1,NNEW(1)
           IR(1)=IX
           DO IY=1,NNEW(2)
            IR(2)=IY
            DO IZ=1,NNEW(3)
             IR(3)=IZ
             JBOX=JBOX+1
             DO IC=1,3
              BOXTAB(1,IC,JBOX)=XCUT(IR(IC),  IC)
              BOXTAB(2,IC,JBOX)=XCUT(IR(IC)+1,IC)
             END DO
            END DO
           END DO
          END DO
          NBOX=NNBOX
         ELSE
C
C UPDATE RMSH AND WMSH
C
          NNMSH=NMSH+NXPT(1)*NXPT(2)*NXPT(3) 
          IF (NNMSH .GT. MAX_PTS) THEN
           write(6,*)'FILLIST: MAX_PTS MUST BE AT LEAST: ',NNMSH
           CALL STOPIT
          END IF
          NSAV=NMSH
          NMSH=0
          DO IX=1,NXPT(1)
           DO IY=1,NXPT(2)
            DO IZ=1,NXPT(3)
             NMSH=NMSH+1 
             RMSH(1,NSAV+NMSH)= RXPT(IX,1)
             RMSH(2,NSAV+NMSH)= RXPT(IY,2)
             RMSH(3,NSAV+NMSH)= RXPT(IZ,3)
             WMSH(NSAV+NMSH)= WXPT(IX,1)*WXPT(IY,2)*WXPT(IZ,3)*NMULT
             RSQR(NMSH)= RXPT(IX,1)**2+RXPT(IY,2)**2+RXPT(IZ,3)**2
            END DO
           END DO
          END DO
C
C PURGE EQIVALENT POINTS
C
          DO IPTS=1,NMSH
           IF (WMSH(NSAV+IPTS) .GT. 0.0D0) THEN
            DO JPTS=IPTS+1,NMSH
             IF (WMSH(NSAV+JPTS) .GT. 0.0D0) THEN
              IF (ABS(RSQR(IPTS)-RSQR(JPTS)) .LE. TOLER) THEN
               DO IGRP=1,NGRP
                DIF= 0.0D0
                DO J=1,3
                 RTMP= 0.0D0
                 DO K=1,3
                  RTMP= RTMP+RMAT(K,J,IGRP)*RMSH(K,NSAV+JPTS)
                 END DO
                 DIF= DIF+ABS(RTMP-RMSH(J,NSAV+IPTS))
                END DO
                IF (DIF .LT. TOLER) GOTO 120
               END DO
               GOTO 130
  120          CONTINUE
               WMSH(NSAV+IPTS)= WMSH(NSAV+IPTS)+WMSH(NSAV+JPTS)
               WMSH(NSAV+JPTS)= -1.0D0
  130          CONTINUE
              END IF
             END IF
            END DO
           END IF
          END DO
C
C GET RID OF EQUIVALENT POINTS
C
          KPTS=NSAV
          DO IPTS=1,NMSH
           IF (WMSH(NSAV+IPTS) .GT. 0.0D0) THEN
            KPTS=KPTS+1
            RMSH(1,KPTS)=RMSH(1,NSAV+IPTS)
            RMSH(2,KPTS)=RMSH(2,NSAV+IPTS)
            RMSH(3,KPTS)=RMSH(3,NSAV+IPTS)
            WMSH(KPTS)=WMSH(NSAV+IPTS)
           END IF
          END DO
          NMSH=KPTS
         END IF
C
C CHECK IF DONE
C
  200    IF (IBOX .LT. NBOX) GOTO 10
        CONTINUE
C
C DEALLOCATE LOCAL ARRAYS
C
        DEALLOCATE(ALTAB,STAT=IERR)
        IF(IERR.NE.0) WRITE(6,*)'FILLIST:ERROR DEALLOCATING ALTAB'
        DEALLOCATE(PREFAC,STAT=IERR)
        IF(IERR.NE.0) WRITE(6,*)'FILLIST:ERROR DEALLOCATING PREFAC'
        DEALLOCATE(RTST,STAT=IERR)
        IF(IERR.NE.0) WRITE(6,*)'FILLIST:ERROR DEALLOCATING RTST'
        DEALLOCATE(XYZWGT,STAT=IERR)
        IF(IERR.NE.0) WRITE(6,*)'FILLIST:ERROR DEALLOCATING XYZWGT'
        DEALLOCATE(CORRECT,STAT=IERR)
        IF(IERR.NE.0) WRITE(6,*)'FILLIST:ERROR DEALLOCATING CORRECT'
        DEALLOCATE(YZDECAY,STAT=IERR)
        IF(IERR.NE.0) WRITE(6,*)'FILLIST:ERROR DEALLOCATING YZDECAY'
        DEALLOCATE(SUMMESH,STAT=IERR)
        IF(IERR.NE.0) WRITE(6,*)'FILLIST:ERROR DEALLOCATING SUMMESH'
        DEALLOCATE(TABINT,STAT=IERR)
        IF(IERR.NE.0) WRITE(6,*)'FILLIST:ERROR DEALLOCATING TABINT'
        DEALLOCATE(TABSUM,STAT=IERR)
        IF(IERR.NE.0) WRITE(6,*)'FILLIST:ERROR DEALLOCATING TABSUM'
        DEALLOCATE(TABNRM,STAT=IERR)
        IF(IERR.NE.0) WRITE(6,*)'FILLIST:ERROR DEALLOCATING TABNRM'
        DEALLOCATE(NPTAB,STAT=IERR)
        IF(IERR.NE.0) WRITE(6,*)'FILLIST:ERROR DEALLOCATING NPTAB'

        RETURN
       END
