       SUBROUTINE ANUMHAM
C
C WRITTEN BY MARK R PEDERSON (1988-1995)
C
#ifndef NOCOMM
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
       LOGICAL EXIST
       COMMON/MIXPOT/POTIN(MAX_PTS*MXSPN),POTDV(MAX_PTS*MXSPN)
#else
       use hstor1,only : hstor
       use mixpot1,only : POTIN,POTDV=>POTOUT
       use mesh1,only   : WMSH,RMSH,NMSH
       use common2,only : ISPN,NSPN
       use common8,only : REP,N_REP,NDMREP,U_MAT,N_SALC,INDBEG,NS_TOT
       INCLUDE 'PARAMA2'
       LOGICAL EXIST,HAVEHAM
       INTEGER :: I,IMODE,IPTR,IPTS,IREC,ISTSCF,KPTS,
     &            KREP,MPTS,MSPN,NDUM,NMAX,NREC
       REAL(8) :: DUMMY,TIME1,TIME2
#endif
C
C IMODE=1 USE O(N)+PARALLEL APPROACH
C IMODE=2 USE STANDARD APPROACH - FASTER FOR SMALL SYSTEMS / FEW CPUS
C
       IMODE=2
C
C
       INQUIRE(FILE='HAMMODE',EXIST=EXIST)
       IF (EXIST) THEN
        OPEN(99,FILE='HAMMODE',FORM='FORMATTED',STATUS='UNKNOWN')
        REWIND(99)
        READ(99,*) IMODE
        REWIND(99)
        WRITE(99,*) IMODE,' 1=O(N)/PARALLEL OR 2=STANDARD'
        CLOSE(99)
       END IF
       IF (IMODE .EQ. 1) THEN
        PRINT '(A)','USING O(N)/PARALLEL HAMILTONIAN ROUTINE'
       ELSE
        PRINT '(A)','USING STANDARD HAMILTONIAN ROUTINE'
       END IF
C
C ZERO POTOLD. READ POTOLD IF POTENTIAL IS USED AS STARTING POINT
C
       CALL GTTIME(TIME1)
       DO 10 IPTS=1,NMSH*NSPN
        POTDV(IPTS)=0.0D0
   10  CONTINUE
       IF (ISTSCF.EQ.2) THEN
        INQUIRE(FILE='POTOLD',EXIST=EXIST)
        IF (.NOT.EXIST) THEN
         PRINT *,'NUMHAM: POTOLD DOES NOT EXIST'
         CALL STOPIT
        END IF
        OPEN(99,FILE='POTOLD',FORM='UNFORMATTED',STATUS='OLD')
        REWIND(99)
        READ(99,END=20)MPTS,MSPN,NDUM
        IF (MPTS.NE.NMSH) THEN
         PRINT *,'NUMHAM: NMSH IN POTOLD DIFFERS FROM CURRENT JOB'
         PRINT*,'MPTS,NMSH=',MPTS,NMSH,MSPN,NDUM
         CALL STOPIT
        END IF
        KPTS=NMSH*MIN(MSPN,NSPN)
        READ(99,END=20)(POTDV(IPTS), IPTS=1,KPTS)
        GOTO 30
   20   PRINT *,'NUMHAM: POTOLD UNREADABLE'
        CALL STOPIT
   30   CLOSE(99)
C
C DEFINE SPIN DOWN POTENTIAL IF POTOLD POTENTIAL IS SPIN UNPOLARIZED
C
        IF ((MSPN.EQ.1).AND.(NSPN.EQ.2)) THEN
         DO 40 IPTS=1,NMSH
          POTDV(IPTS+NMSH)=POTDV(IPTS)
   40    CONTINUE
        END IF
C
C MULTIPLY POTENTIAL BY WMSH AND CALL CORRECT SUBROUTINE
C
        IPTR=(ISPN-1)*NMSH
        DO IPTS=1,NMSH
         POTDV(IPTS)=WMSH(IPTS)*POTDV(IPTS+IPTR)
        END DO
        IF (IMODE.EQ.1) THEN
         CALL OVERNUM(1)
        ELSE
         CALL PATCH(POTDV)
        END IF
       END IF
C
C USE OLD HAMILTONIAN OR WRITE NEW ONE
C
       NREC=0
       DO 510 KREP=1,N_REP
        NREC=NREC+(NS_TOT(KREP)*(NS_TOT(KREP)+1))/2
  510  CONTINUE
       IF (ISTSCF.EQ.1) THEN
        PRINT '(A)','USING OLD HAMILTONIAN'
        INQUIRE(FILE='HAMOLD',EXIST=EXIST)
        IF (.NOT.EXIST) THEN
         PRINT *,'NUMHAM: HAMOLD DOES NOT EXIST'
         CALL STOPIT
        END IF
        OPEN(99,FILE='HAMOLD',FORM='UNFORMATTED',STATUS='OLD')
        REWIND(99)
        READ(99,END=530)NREC,MSPN
        IF (MSPN.EQ.1) THEN
         READ(99,END=530)(HSTOR(IREC,2),IREC=1,NREC)
        ELSE IF (MSPN.EQ.2) THEN
         DO 520 I=1,ISPN
          READ(99,END=530)(HSTOR(IREC,2),IREC=1,NREC)
  520    CONTINUE
        ELSE
         GOTO 530
        END IF
        GOTO 540
  530   PRINT *,'NUMHAM: HAMOLD UNREADABLE'
        CALL STOPIT
  540   CLOSE(99)
       ELSE
        OPEN(99,FILE='HAMOLD',FORM='UNFORMATTED',STATUS='UNKNOWN')
        REWIND(99)
        IF (ISPN.EQ.1) THEN
         WRITE(99)NREC,NSPN
         WRITE(99)(HSTOR(IREC,2),IREC=1,NREC)
        ELSE
         READ(99)NDUM
         READ(99)DUMMY
         WRITE(99)(HSTOR(IREC,2),IREC=1,NREC)
        END IF
        CLOSE(99)
       END IF
       HAVEHAM=.TRUE.
       CALL GTTIME(TIME2)
       CALL TIMOUT('POTENTIAL MATRIX ELEMENTS:         ',TIME2-TIME1)
       CLOSE(45,STATUS='DELETE')
       RETURN
       END
C
C ********************************************************************
C
C CONSTRUCT MATRIX ELEMENTS OF POTENTIAL
C MARK PEDERSON AUG 1995
C
       SUBROUTINE APATCH(POTDV)
C
C WRITTEN BY MARK R PEDERSON
C 02/12/97 David Clay Patton
C
#ifndef NOCOMM
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
       PARAMETER (NMAX=MPBLOCK)
       DIMENSION POTDV(*)
#else
       use hstor1, only : hstor
       use xtmp2a, only : PSIBR,PSIB,VOL,QR
       !use WTSFOD, only : WTFOD
       use mesh1,only   : WMSH,RMSH,NMSH
!      use common2,only : ISPN,NSPN
       use common8,only : REP,N_REP,NDMREP,U_MAT,N_SALC,INDBEG,NS_TOT,
     &                    LDMREP
       use for_diag1
       INCLUDE 'PARAMA2'
       REAL(8),INTENT(IN) :: POTDV(*)
       INTEGER :: NMAX=MPBLOCK
       INTEGER :: IBAS,IND,INDX,IST,JBAS,JND,KREP,KROW,LPTS,
     &            MDCL,MPTS,NBAS
       REAL(8) :: BASPHI,ERROR
#endif
C
C SCRATCH COMMON BLOCK FOR LOCAL ARRAYS
C
#ifndef NOCOMM
       COMMON/TMP2/PSIBR(MPBLOCK,5*NDH),PSIB(MPBLOCK)
     &  ,VOL(MPBLOCK),QR(3,MPBLOCK)
       COMMON/WTSFOD/WTFOD
#endif
       DIMENSION BASPHI(MAX_OCC*2)   
       LOGICAL LSETUP
       DATA MDCL/2/
       MDCL=1
C JUn 12 2022 -- USE MDCL=2 
       BASPHI=0.0D0
C GAM=   REPRESENATION INDEX, L=ROW OF REPRESENATION
C MDCL=1 CALCULATE MATRIX ELEMENTS BY ROTATING EACH MESH POINT TO
C        EQUIVALENT POINTS AND FIND <PSI(I,GAM,L)|V(I)|PSI(I,GAM,L)>
C        SUMMED OVER I WITH L=1
C MDCL=2 CALCULATE MATRIX ELEMENTS BY USING ONLY INEQUVIALENT POINTS
C        AND FIND <PSI(I,GAM,L)|V(I)|PSI(I,GAM,L)> SUMMED OVER I AND L
C
       IF (NMSH.GT.MAX_PTS) THEN
        PRINT *,'PATCH: MAX_PTS MUST BE AT LEAST', NMSH
        CALL STOPIT
       END IF
C
C      INITIALIZE ARRAY INDEX IN GETBAS
C
       LSETUP=.TRUE.
       CALL AGETBAS(LSETUP,0,0,QR,PSIBR,0,NBAS)
C
       DO LPTS=0,NMSH-1,NMAX
        MPTS=MIN(NMAX,NMSH-LPTS)
        CALL NEWWAY(LPTS,MPTS,MDCL,POTDV,BASPHI)
       END DO
C      DO I=1,13  
C      PRINT 555,I,BASPHI(I)   ! <B^GAMMA^ROW_N | PHI_I>
C      END DO
       IST=0
       INDX=0
       DO KREP=1,N_REP
          HAM=0.0D0
       DO KROW=1,NDMREP(KREP)/LDMREP(KREP)
          DO IBAS=1,NS_TOT(KREP)
          IND=IST+IBAS
          DO JBAS=1,NS_TOT(KREP)
          JND=IST+JBAS
          HAM(JBAS,IBAS)=HAM(JBAS,IBAS)+BASPHI(IND)*BASPHI(JND)
C FIND SUM_FLO <IBAS|FLO><FLO|JBAS> (SUMMED OVER ALL FLOS)
          END DO
          END DO
          IST=IST+NS_TOT(KREP)
       END DO
          DO IBAS=1    ,NS_TOT(KREP)
          DO JBAS=IBAS,NS_TOT(KREP)
          INDX=INDX+1
          HSTOR(INDX,2)=HSTOR(INDX,2)+
     &           (HAM(JBAS,IBAS)+HAM(IBAS,JBAS))/2.0D0
          END DO
          END DO
       END DO
      
        ERROR=0.0D0
C       DO I=1,3292
C       PRINT 555,HSTOR(I,1), HSTOR(I,2),HSTOR(I,2)/HSTOR(I,1)
C       ERROR=ERROR+ABS(HSTOR(I,1)-HSTOR(I,2))/(ABS(HSTOR(I,1)+1.0D-10))
C       END DO
 555   FORMAT(I5,3F16.8)
 556   FORMAT(8F16.8)
       END
C
C ********************************************************************
C
      SUBROUTINE NEWWAY(LPTS,MPTS,MDCL,POTDV,BASPHI)
#ifndef NOCOMM
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
#else
       use common8,only : REP,N_REP,NDMREP,U_MAT,N_SALC,INDBEG,NS_TOT,
     &                    LDMREP
       use xtmp2a, only : PSIBR,PSIB,VOL,QR
       use hstor1, only : hstor
       use mesh1, only : NMSH,RMSH,WMSH
       INCLUDE 'PARAMA2'
       INTEGER,INTENT(IN) :: LPTS,MPTS,MDCL
       REAL(8),INTENT(IN) :: POTDV(*)
       REAL(8),INTENT(OUT) :: BASPHI(*)
       INTEGER :: IBG,IBT,ICNT,IPTS,ISS,KREP,KROW,NBAS
#endif
      LOGICAL LSETUP
#ifndef NOCOMM
      DIMENSION POTDV(*),BASPHI(*)
      COMMON/TMP2/PSIBR(MPBLOCK,5*NDH),PSIB(MPBLOCK)
     & ,VOL(MPBLOCK),QR(3,MPBLOCK)
#else
      ALLOCATE(PSIBR(MPBLOCK,5*NDH))
      ALLOCATE(PSIB(MPBLOCK))
      ALLOCATE(VOL(MPBLOCK))
      ALLOCATE(QR(3,MPBLOCK))
#endif
      LSETUP=.FALSE.
      DO IPTS=1,MPTS
       VOL( IPTS)=POTDV(LPTS+IPTS)       
       QR(1,IPTS)=RMSH(1,LPTS+IPTS)
       QR(2,IPTS)=RMSH(2,LPTS+IPTS)
       QR(3,IPTS)=RMSH(3,LPTS+IPTS)
      END DO
      ICNT=0
      IBT=0
      DO  KREP=1,N_REP
      CALL AGETBAS(LSETUP,MPTS,1,QR,PSIBR,KREP,NBAS)
                     
C     PRINT*,'KREP:',KREP,' NBAS:',NBAS,' DEG:',NDMREP(KREP)
      DO   KROW=1,1!NDMREP(KREP)
        IBG=(KROW-1)*NDMREP(KREP)
        DO  ISS=1,NBAS
        IBT=IBT+1
        DO IPTS=1,MPTS
        BASPHI(IBT)=BASPHI(IBT)+VOL(IPTS)*PSIBR(IPTS,ISS+IBG)
        END DO
        END DO
      END DO
      ICNT=IBT
      END DO
#ifdef NOCOMM
      DEALLOCATE(PSIBR)
      DEALLOCATE(PSIB)
      DEALLOCATE(VOL)
      DEALLOCATE(QR)
#endif
 
      END
      SUBROUTINE AHAMMAT(LPTS,MPTS,MDCL,POTDV,INDX)
C
C 02/12/97 David Clay Patton
C
#ifndef NOCOMM
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
      LOGICAL LSETUP
      DIMENSION POTDV(*)
      COMMON/TMP2/PSIBR(MPBLOCK,5*NDH),PSIB(MPBLOCK)
     & ,VOL(MPBLOCK),QR(3,MPBLOCK)
#else
       use hstor1, only : hstor
       use mesh1,  only : NMSH,RMSH,WMSH
       use xtmp2a, only : PSIBR,PSIB,VOL,QR
       use common3,only : NGRP
       use common8,only : REP,N_REP,NDMREP,U_MAT,N_SALC,INDBEG,NS_TOT,
     &                    LDMREP
       INCLUDE 'PARAMA2'
       LOGICAL LSETUP
       INTEGER,INTENT(IN) :: LPTS,MPTS,MDCL
       REAL(8),INTENT(IN) :: POTDV(*)
       INTEGER,INTENT(OUT) :: INDX
       INTEGER :: IBG,IGP,IPTS,ISS,JGP,JNDX,JREP,JSS,KREP,
     &            KRP,MGRP,NBAS,NRP
       REAL(8) :: DOT

       ALLOCATE(PSIBR(MPBLOCK,5*NDH))
       ALLOCATE(PSIB(MPBLOCK))
       ALLOCATE(VOL(MPBLOCK))
       ALLOCATE(QR(3,MPBLOCK))
#endif
C
      MGRP=1
      IF (MDCL.EQ.1) MGRP=NGRP
C
      LSETUP=.FALSE.
      DO IPTS=1,MPTS
       VOL(IPTS)=POTDV(LPTS+IPTS)/MGRP
       QR(1,IPTS)=RMSH(1,LPTS+IPTS)
       QR(2,IPTS)=RMSH(2,LPTS+IPTS)
       QR(3,IPTS)=RMSH(3,LPTS+IPTS)
      END DO
C
C UPDATE MATRIX ELEMENTS HERE:
C
      DO 100 IGP=1,MGRP
       JGP=IGP
       INDX=0
       DO 200 KREP=1,N_REP
        JREP=KREP
        IF (MDCL.EQ.1) THEN
         NRP=1
        ELSE
         NRP=NDMREP(KREP)
        END IF
        CALL AGETBAS(LSETUP,MPTS,JGP,QR,PSIBR,JREP,NBAS)
C NBA
        JNDX=INDX
        DO 300 KRP=1,NRP  !Loop over rows
         INDX=JNDX
         IBG=(KRP-1)*NBAS
         DO 400 ISS=1,NBAS
          DO IPTS=1,MPTS
           PSIB(IPTS)=PSIBR(IPTS,ISS+IBG)*VOL(IPTS)/NRP
          END DO
C
C NOTE: WE COULD MAKE USE OF SPARCITY HERE. IF PSIB=0 AT EACH
C       MESHPOINT, THE NEXT LOOP CAN BE SKIPPED - INDX MUST BE
C       RESET OF COURSE
C
          DO JSS=ISS,NBAS
           DOT=0.0D0
           DO IPTS=1,MPTS
            DOT=DOT+PSIB(IPTS)*PSIBR(IPTS,JSS+IBG)
           END DO
           INDX=INDX+1
           HSTOR(INDX,2)=HSTOR(INDX,2)+DOT
          END DO
400      CONTINUE
300     CONTINUE
200    CONTINUE
100   CONTINUE
                PRINT*,'INDX 3292 5638:',INDX
#ifdef NOCOMM
      DEALLOCATE(PSIBR)
      DEALLOCATE(PSIB)
      DEALLOCATE(VOL)
      DEALLOCATE(QR)
#endif
      RETURN
      END
C
C ******************************************************************\
C
       SUBROUTINE AGETBAS(LSETUP,MPTS,IGP,R,PSIBR,JREP,NBAS)
C
C CALCULATES THE VALUE OF ALL SALC BASIS FUNCTIONS FOR A
C BUNCH OF MESH POINTS AND STORES THEM IN PSIBR
C WRITTEN BY MARK R PEDERSON
C DVP: THIS ROUTINE MAY NOT BE CALLED WITH ARBITRARY MPTS/R/IGP/JREP
C ARGUMENTS. FOR A PARTICULAR SET MPTS/R OF POINTS, IT MUST BE CALLED
C WITH JREP=IGP=1 FIRST AND CAN ONLY BE CALLED WITH OTHER JREP/IGP
C ARGUMENTS IF MPTS/R DOES NOT CHANGE.
C
#ifndef NOCOMM
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
       LOGICAL LSETUP
#else
       use debug1,only : DEBUG
       use common2,only : RIDT,IFUIDT,NIDENT,ZNUC,BFCON,N_BARE,
     &                    N_CON,LSYMMAX,N_POS,NFNCT,ISPN
       use common8,only : REP,N_REP,NDMREP,U_MAT,N_SALC,INDBEG,NS_TOT

       INCLUDE 'PARAMA2'
       LOGICAL,INTENT(IN) :: LSETUP
       REAL(8),INTENT(IN) :: R
       REAL(8),INTENT(OUT) :: PSIBR
       INTEGER,INTENT(IN) :: MPTS,IGP,JREP
       INTEGER,INTENT(OUT) :: NBAS
#endif
       DIMENSION PSIBR(MPBLOCK,5*NDH),R(3,MPBLOCK)
#ifndef NOCOMM
       COMMON/TMP6/ORBT(MPBLOCK,10,MAX_CON,3)
     &  ,PSIBS(MPBLOCK,MAXSLC*MAX_IDENT)
     &  ,CONORB(MPBLOCK,MAX_CON,3),ANGLE(MPBLOCK,10),DTS(3,MPBLOCK)
     &  ,RVEC(3),RVECA(3,MX_GRP),NSALC(MAX_REP)
     &  ,INDEX(ISMAX,MAX_CON,3,MAX_IDENT,MAXSYMSALC)
#else
        REAL(8) :: ORBT(MPBLOCK,10,MAX_CON,3),
     &             PSIBS(MPBLOCK,MAXSLC*MAX_IDENT),
     &             CONORB(MPBLOCK,MAX_CON,3),
     &             ANGLE(MPBLOCK,10),
     &             DTS(3,MPBLOCK),
     &             RVEC(3),RVECA(3,MX_GRP)
        INTEGER :: NSALC(MAX_REP),
     &             INDEX(ISMAX,MAX_CON,3,MAX_IDENT,MAXSYMSALC)

        INTEGER :: I_POS,IBEG,IC,IEND,IFNCT,ILOC,INS,IPTS,IQ,IR,
     &             IREP,IROW,IS,ISALC,ISHELLA,ISS,JR,K_POS,KSHELL,
     &             LI,M_NUC,MU,NBI,NBI_BEG,NDEG,NSC
        REAL(8) :: FAC,T1
        SAVE
#endif
       DIMENSION IBEG(3),IEND(3),NDEG(3)
       DATA IBEG,IEND,NDEG/1,2,5,1,4,10,1,3,6/
C
C IF (LSETUP), SET UP INDEX ARRAY FOR SALCS
C
       IF (LSETUP) THEN
        INS=0
        ISALC=0
        DO IREP=1,N_REP
         DO IROW=1,NDMREP(IREP)
          ISALC=ISALC+1
          ISHELLA=0
          NSC=0
          DO IFNCT=1,NFNCT
           DO I_POS=1,N_POS(IFNCT)
            ISHELLA=ISHELLA+1
            RVEC(1)=RIDT(1,ISHELLA)
            RVEC(2)=RIDT(2,ISHELLA)
            RVEC(3)=RIDT(3,ISHELLA)
            CALL OBINFO(1,RVEC,RVECA,M_NUC,KSHELL)
            CALL GSMAT(KSHELL,1)
            DO LI=1,LSYMMAX(IFNCT)+1
             DO IC=1,N_CON(LI,IFNCT)
              DO IQ=1,N_SALC(ISALC,LI,KSHELL)
               INS=INS+1
               NSC=NSC+1
               INDEX(IQ,IC,LI,ISHELLA,ISALC)=INS
              END DO
             END DO
            END DO
           END DO
          END DO
         END DO
         IF (DEBUG) PRINT *,'IREP,IROW-1,NSC',IREP,IROW-1,NSC
         NSALC(IREP)=NSC
        END DO
        IF (DEBUG) THEN
         PRINT *,'GETBAS: TOTAL NUMBER OF BASIS FUNCTIONS:',INS
        END IF
        RETURN
       END IF
C
       IF (MPTS.GT.MPBLOCK) THEN
        PRINT *,'MPTS MUST BE:',MPBLOCK
        CALL STOPIT
       END IF
C
C INIT PSIBS
C
       IF ((IGP.EQ.1).AND.(JREP.EQ.1)) THEN
        DO IS=1,INS
         DO IPTS=1,MPTS
          PSIBS(IPTS,IS)=0.0D0
         END DO
        END DO
        ISHELLA=0
        CALL GTTIME(T1)
        DO 250 IFNCT=1,NFNCT
         DO 240 I_POS=1,N_POS(IFNCT)
          ISHELLA=ISHELLA+1
          RVEC(1)=RIDT(1,ISHELLA)
          RVEC(2)=RIDT(2,ISHELLA)
          RVEC(3)=RIDT(3,ISHELLA)
          CALL OBINFO(1,RVEC,RVECA,M_NUC,KSHELL)
          CALL GSMAT(KSHELL,1)
          DO 230 K_POS=1,M_NUC
           DO IPTS=1,MPTS
            DTS(1,IPTS)=R(1,IPTS)-RVECA(1,K_POS)
            DTS(2,IPTS)=R(2,IPTS)-RVECA(2,K_POS)
            DTS(3,IPTS)=R(3,IPTS)-RVECA(3,K_POS)
           END DO
           CALL GTORBNH(MPTS,DTS,IFNCT,ANGLE,CONORB)
           DO  LI=1,LSYMMAX(IFNCT)+1
            DO  IC=1,N_CON(LI,IFNCT)
             DO  MU=IBEG(LI),IEND(LI)
              DO  IPTS=1,MPTS
               ORBT(IPTS,MU,IC,LI)=CONORB(IPTS,IC,LI)*ANGLE(IPTS,MU)
              END DO
             END DO
            END DO
           END DO
C
           ISALC=0
           NBI_BEG=0
           DO IREP=1,N_REP
            DO IROW=1,NDMREP(IREP)
             ISALC=ISALC+1
             DO LI=1,LSYMMAX(IFNCT)+1
              ILOC=NDEG(LI)*(K_POS-1)-IBEG(LI)+1
              DO MU=IBEG(LI),IEND(LI)
               NBI=NBI_BEG
               DO IC=1,N_CON(LI,IFNCT)
                DO IQ=1,N_SALC(ISALC,LI,KSHELL)
                 INS=INDEX(IQ,IC,LI,ISHELLA,ISALC)
                 FAC= U_MAT(ILOC+MU,IQ,ISALC,LI,1)
                 NBI=NBI+1
                 DO IPTS=1,MPTS
                  PSIBS(IPTS,INS)=PSIBS(IPTS,INS)
     &            +FAC*ORBT(IPTS,MU,IC,LI)
                 END DO
                END DO
               END DO
              END DO
              NBI_BEG=NBI
             END DO
            END DO
           END DO
           IF (NBI.GT.MAXSLC) THEN
            PRINT *,'NUMHAM: MAXSLC MUST BE AT LEAST: ',NBI
            CALL STOPIT
           END IF
 230      CONTINUE
 240     CONTINUE
 250    CONTINUE
       END IF
C
       INS=0
       DO IREP=1,N_REP
        IF (IREP.EQ.JREP) THEN
         NBAS=NSALC(IREP)
         DO ISS=1,NSALC(IREP)
          INS=INS+1
          DO IR=1,NDMREP(IREP)
           DO IPTS=1,MPTS
            PSIBR(IPTS,ISS+(IR-1)*NSALC(IREP))=0.0D0
           END DO
           DO JR=1,NDMREP(IREP)
            DO IPTS=1,MPTS
             PSIBR(IPTS,ISS+(IR-1)*NSALC(IREP))=
     &       PSIBR(IPTS,ISS+(IR-1)*NSALC(IREP))+
     &       PSIBS(IPTS,INS+(JR-1)*NSALC(IREP))*REP(JR,IR,IGP,IREP)
            END DO
           END DO
          END DO
         END DO
         INS=INS+(NDMREP(IREP)-1)*NSALC(IREP)
        ELSE
         INS=INS+ NDMREP(IREP)   *NSALC(IREP)
        END IF
       END DO
       RETURN
       END
C
       SUBROUTINE ASCISSOR(IREP)
C MARK R. PEDERSON 20 NOVEMBER 2000
C
C NOTE: FORCES NOT NECESSARILY CORRECT....
C OK FOR SINGLE GEOMETRIES....
C *********************************************************************
C
C THIS PROGRAM CREATES "SCISSOR" WHICH LISTS EACH BASIS FUNCTION
C ON EACH ATOM AS SOMETHING LIKE...
C
C
C1  6. FUNCTION SET
C     1 IP:  1 POSITION:       0.000000       0.000000       0.000000
C  1  0  0.00  0.00 1S ATOMIC ORBITAL
C  2  0  0.00  0.00 2S ATOMIC ORBITAL
C  3  0  0.00  0.00  S(BARE GAUSSIAN)
C  4  0  0.00  0.00  S(BARE GAUSSIAN)
C  5  0  0.00  0.00  S(BARE GAUSSIAN)
C  2  1  0.00  0.00 2P ATOMIC ORBITAL
C  3  1  0.00  0.00  P(BARE GAUSSIAN)
C  4  1  0.00  0.00  P(BARE GAUSSIAN)
C  5  1  0.00  0.00  P(BARE GAUSSIAN)
C  3  2  0.00  0.00  D(BARE GAUSSIAN)
C  4  2  0.00  0.00  D(BARE GAUSSIAN)
C  5  2  0.00  0.00  D(BARE GAUSSIAN)
C
C
C TO ADD A SCISSOR SHIFT OF 27.2 eV TO, FOR EXAMPLE THE CARBON 1S UP
C  ORBITAL WE CHANGE:
C
C  1  0  0.00  0.00 1S ATOMIC ORBITAL
C TO:
C  1  0 -1.00  0.00 1S ATOMIC ORBITAL
C
C
#ifndef NOCOMM
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
#else
       use debug1,only : DEBUG
       use common2,only : RIDT,IFUIDT,NIDENT,ZNUC,BFCON,N_BARE,
     &                    N_CON,LSYMMAX,N_POS,NFNCT,ISPN
       !use common3,only : RMAT
       use common8,only : REP, NDMREP, N_SALC
       use for_diag1
       INCLUDE 'PARAMA2'
       INTEGER,INTENT(IN) :: IREP
       INTEGER :: I,IADD,IBAS,IBEG,ICON,IDUM,IEND,IFNCT,IID,IND_SALC,
     &            IPOINT,
     &            IPOS,ISALC,ISHELL,JBAS,JDUM,KBAS,KREP,KSALC,L,
     &            LNDX,NADD,NBAS,NBSMAX,NDEG,NORBS,NSITE,
     &            MNUC,MSITES
       REAL(8) :: AI,AJ,FACT,RNUC,RNUCI,RNUCJ,SHFT,SS,DIAG
#endif
       CHARACTER*7 FNAME
       CHARACTER*1 NAM(4)
       LOGICAL EXIST,SCISS
       DIMENSION NDEG(3),AI(3),AJ(3),IPOINT(MAX_REP)
       DIMENSION SS(10,10)
       DIMENSION RNUCI(3,MX_GRP),RNUCJ(3,MX_GRP)
       DIMENSION IBEG(3),IEND(3)
       DIMENSION IND_SALC(ISMAX,MAX_CON,3,2)
       DIMENSION SHFT(MAX_CON,3,2,MAX_FUSET)
       DIMENSION LNDX(6,MAX_CON,3,2)
       DIMENSION RNUC(3,MX_GRP)
       DATA NDEG/1,3,6/
       DATA IBEG,IEND/1,2,5,1,4,10/
       DATA NAM/'S','P','D','F'/
       DATA SCISS/.FALSE./
       INQUIRE(FILE='SCISSOR',EXIST=EXIST)
       IF(.NOT.EXIST)RETURN
          OPEN(70,FILE='SCISSOR')
          READ(70,*,END=420)SCISS
          IF(.NOT.SCISS) THEN
            CLOSE(70)
            RETURN
           ENDIF
          GOTO 430
 420   CONTINUE
       EXIST=.FALSE.
       IF(.NOT.EXIST) WRITE(70,*)SCISS,' IF SCISSOR=T PLEASE RUN WITH
     & PURGRSQ= T !!!'
 430   CONTINUE
        NORBS=0
        NBSMAX=0
        IID=0
        DO 10 IFNCT=1,NFNCT
         NSITE=0
         IF(.NOT.EXIST)THEN
         WRITE(70,*)IFNCT,ZNUC(IFNCT),' FUNCTION SET'
         ELSE
         READ(70,*)IDUM
         END IF
         DO IPOS=1,N_POS(IFNCT)
          IID=IID+1
          CALL GASITES(1,RIDT(1,IID),MNUC,RNUC,MSITES)
          NSITE=NSITE+MNUC
          IF(.NOT.EXIST)THEN
          WRITE(70,1010) IFNCT,IPOS,(RIDT(I,IID),I=1,3)
          ELSE
          READ(70,*)IDUM
          END IF
 1010     FORMAT('    ',I3,' IP:',I3,' POSITION:',3F15.6)
         END DO
         NADD=N_CON(1,IFNCT)+3*N_CON(2,IFNCT)+6*N_CON(3,IFNCT)
         NORBS=NORBS+NADD*NSITE
         NBSMAX=MAX(NBSMAX,NADD)
         DO L=0,LSYMMAX(IFNCT)
          DO ICON=1,N_CON(L+1,IFNCT)
          IADD=0
           DO I=1,N_BARE(IFNCT)
           IF(ABS(BFCON(I,ICON,L+1,IFNCT)).GT.1D-5) IADD=IADD+1
           END DO
          IF(IADD.GT.1)THEN
          IF(.NOT.EXIST)THEN
          WRITE(70,1020)ICON+L,L,ICON+L,NAM(L+1)
          ELSE
          READ(70,*   )IDUM,JDUM,SHFT(ICON,L+1,1,IFNCT)
     &                          ,SHFT(ICON,L+1,2,IFNCT)
          END IF
 1020     FORMAT(' ',2I3,'  0.00  0.00 ',I1,A1,' ATOMIC ORBITAL')
          ELSE
          IF(.NOT.EXIST)THEN
          WRITE(70,1021)ICON+L,L,       NAM(L+1)
          ELSE
          READ(70,*   )IDUM,JDUM,SHFT(ICON,L+1,1,IFNCT)
     &                          ,SHFT(ICON,L+1,2,IFNCT)
          END IF
 1021     FORMAT(' ',2I3,'  0.00  0.00  ',   A1,'(BARE GAUSSIAN)')
          END IF
          END DO
         END DO
   10   CONTINUE
        NBAS=0.0D0
        DO 20 IID=1,NIDENT
         IF(DEBUG) PRINT*,'IID:',IID
         IFNCT=IFUIDT(IID)
         CALL OBINFO(1,RIDT(1,IID),RNUC,MNUC,ISHELL)
         CALL GSMAT(ISHELL,2)
         KSALC=0
         DO KREP=1,IREP
          KSALC=KSALC+NDMREP(KREP)
         END DO
          DO L=0,LSYMMAX(IFNCT)
C NOTE THEN NEXT TWO DO LOOPS MAY NEED TO BE PERMUTED.
          DO ICON=1,N_CON(L+1,IFNCT)
          DO ISALC=1,N_SALC(KSALC,L+1,ISHELL)
          NBAS=NBAS+1
          EVAL(NBAS)=SHFT(ICON,L+1,ISPN,IFNCT)/OVER(NBAS,NBAS)
          IF(DEBUG) THEN
          PRINT 1030,NBAS,HAM(NBAS,NBAS),OVER(NBAS,NBAS),
     &             SHFT(ICON,L+1,ISPN,IFNCT),EVAL(NBAS)
          ENDIF
          END DO
          END DO
          END DO
 1030   FORMAT(' ',I5,4F12.4)
   20   CONTINUE
                         DO IBAS=1,NBAS
                         DO JBAS=IBAS,NBAS
                         OVER(IBAS,JBAS)=OVER(JBAS,IBAS)
                         END DO
                         END DO
       DO IBAS=1,NBAS
        IF(ABS(EVAL(IBAS)).GE.0.000001)THEN
        DO JBAS=1   ,NBAS
         FACT=EVAL(IBAS)*OVER(IBAS,JBAS)
         DO KBAS=JBAS,NBAS
          HAM(KBAS,JBAS)=HAM(KBAS,JBAS)+FACT*OVER(KBAS,IBAS)
         END DO
        END DO
        END IF
       END DO
       CLOSE(70)
       RETURN
       END
       SUBROUTINE ANEWOCC(NITER,TRACE)
C
C WRITTEN BY MARK R PEDERSON (1986-1989)
c
#ifndef NOCOMM
       INCLUDE 'PARAMS'
       INCLUDE 'commons.inc'
#else
       use mixpot1,only : POTIN,POTDV=>POTOUT
       use common2,only : RIDT,N_CON,LSYMMAX,N_POS,NFNCT,IGGA,ISPN,NSPN
       use common5,only : NWFS,NWF,PSI_COEF,OCCUPANCY,N_OCC,PSI,
     &                    EVLOCC
       use common8,only : REP,N_REP,NDMREP,U_MAT,N_SALC,INDBEG,NS_TOT
       use for_diag1
       use hstor1,only : hstor
       INCLUDE 'PARAMA2'
       INTEGER,INTENT(IN) :: NITER
       REAL(8),INTENT(OUT) :: TRACE
       INTEGER :: IB,IBAS,IDEG,IEIG,INDREP,IOCC,IOFS,IREP,ISAV,ISORT,
     &            ISPFAC,IVIRT,JBAS,JSORT,JVIRT,KBAS,
     &            KVIRT,L,
     &            MAX_TOT,N_VIRT,NBAS,NDEG,NEIG,NOCCU,NSAV,NTEMP,
     &            NVIRT_UP,NVIRTTOT
       REAL(8) :: CUTOCC,DIAG,DSINGV,E_DN,E_UP,ECUT,EF,ELEC,ESPN,
     &            EVALSAV,
     &            OCCTMP,TEMP,TIME1,TIME2
#endif
       PARAMETER (MAX_TOT=NDH*MAX_REP)
       LOGICAL EXIST,FERMISTAT
       LOGICAL AVERAGE,EF_MODE,HAMAVG,RENORM
       CHARACTER*4 FLINE
       CHARACTER*12 EVALSTR
       CHARACTER*7 NAMES
       DIMENSION NAMES(3)
       DIMENSION EVALSAV(MAX_TOT*MXSPN),OCCTMP(MAX_TOT*MXSPN)
       DIMENSION NDEG(MAX_TOT*MXSPN),INDREP(MAX_TOT*MXSPN),
     &  NSAV(MAX_REP,MXSPN)
       DIMENSION N_VIRT(MAX_REP,MXSPN)
       DIMENSION DIAG(NDH,MAX_REP)
       DIMENSION NTEMP(MAX_TOT*MXSPN)
#ifndef NOCOMM
       COMMON/MIXPOT1/POTIN(MAX_PTS*MXSPN),POTOUT(MAX_PTS*MXSPN)
#endif
C
C DEFINE TEMPERATURE, MINIMUM OCCUPANCY AND SMALLEST ALLOWED
C EIGENVALUE OF OVERLAP MATRIX FOR SINGULAR VALUE DECOMPOSITION
C
       DATA TEMP  /1.0D-4/
       DATA CUTOCC/1.0D-10/
       DATA DSINGV/2.0D-4/
       DATA NAMES/'BROYDEN','KBROY1','KBROY2'/
       IF (N_REP.GT.MAX_REP) THEN
        PRINT *,'NEWWAVE: MAX_REP MUST BE AT LEAST: ',N_REP
        CALL STOPIT
       END IF
       TRACE=0.0D0
       CALL OVERLAP(1)
       IF (NSPN.GT.MXSPN) THEN
        PRINT *,'NEWWAVE: MXSPN MUST BE AT LEAST: ',NSPN
        CALL STOPIT
       END IF
C
C CHECK IF FROZEN OCCUPATION MODE
C
       WRITE(EVALSTR,'(A,I3.3)')'EVAL',NITER
       OPEN(97,FILE='EVALUES',FORM='FORMATTED',STATUS='UNKNOWN')
       OPEN(98,FILE=EVALSTR,FORM='FORMATTED',STATUS='UNKNOWN')
       READ(97,1000,END=60,ERR=60)FLINE
 1000  FORMAT(A4)
        FERMISTAT=.FALSE.
        IOCC=0
        DO 30 ISPN=1,NSPN
         DO 20 IREP=1,N_REP
          READ(97,*)N_OCC(IREP,ISPN)
          IF (N_OCC(IREP,ISPN).GT.MAX_VIRT_PER_SYM) THEN
           PRINT *,'NEWWAVE: MAX_VIRT_PER_SYM MUST BE AT LEAST: ',
     &              N_OCC(IREP,ISPN)
           CALL STOPIT
          END IF
          IF (N_OCC(IREP,ISPN).GT.0) THEN
           READ(97,*)(OCCUPANCY(L),L=IOCC+1,IOCC+N_OCC(IREP,ISPN))
           IOCC=IOCC+N_OCC(IREP,ISPN)
          END IF
   20    CONTINUE
   30   CONTINUE
        REWIND(97)
        WRITE(97,1100)FLINE
        WRITE(98,1100)FLINE
 1100   FORMAT(A4)
        IOCC=0
        DO 50 ISPN=1,NSPN
        ESPN=0.0D0
         DO 40 IREP=1,N_REP
          WRITE(97,*)N_OCC(IREP,ISPN)
          WRITE(97,1200)(OCCUPANCY(L),L=IOCC+1,IOCC+N_OCC(IREP,ISPN))
          WRITE(98,*)N_OCC(IREP,ISPN)
          WRITE(98,1200)(OCCUPANCY(L),L=IOCC+1,IOCC+N_OCC(IREP,ISPN))
                    DO L=IOCC+1,IOCC+N_OCC(IREP,ISPN)
                    ESPN=ESPN+OCCUPANCY(L)*NDMREP(IREP)
                    END DO
 1200     FORMAT(' ',5G15.7)
          IOCC=IOCC+N_OCC(IREP,ISPN)
   40    CONTINUE
              IF(ISPN.EQ.1)E_UP=ESPN
              IF(ISPN.EQ.2)E_DN=ESPN
   50   CONTINUE
        GOTO 65
   60  REWIND(97)
   65  CONTINUE
       NOCCU=0
       NWF=0
       PRINT '(A)','CONSTRUCTING NEW WAVEFUNCTIONS'
       CALL GTTIME(TIME1)
       ELEC=E_UP+E_DN
       ISPFAC=2/NSPN
        NVIRTTOT=0
       L=0
       DO 240 ISPN=1,NSPN
        NWFS(ISPN)=0
        IF(FLINE.EQ.'FIXM' .OR. FLINE.EQ.'fixm') THEN
          WRITE(97,1100)FLINE
          WRITE(6,1100)FLINE
        ENDIF
        WRITE(97,*)'********* NEW TRY ************, SPIN: ',ISPN
        WRITE(98,*)'********* NEW TRY ************, SPIN: ',ISPN

        PRINT '(A,I1,A)','SPIN ',ISPN,':'
        CALL OVERLAP(2)
        CALL OVERLAP(1)
C
C LOOP OVER REPRESENTATIONS
C GET MATRIX ELEMENTS
C
        KBAS=0
        DO 130 IREP=1,N_REP
         N_VIRT(IREP,ISPN)=0
         NBAS=NS_TOT(IREP)
         IF (NBAS.GT.NDH) THEN
          PRINT *,'NEWWAVE: NDH MUST BE AT LEAST: ',NBAS
          CALL STOPIT
         END IF

         DO 80 IBAS=1,NBAS
          DO 70 JBAS=IBAS,NBAS
           KBAS=KBAS+1
           OVER(JBAS,IBAS)=HSTOR(KBAS,1)
           HAM (JBAS,IBAS)=HSTOR(KBAS,2)
   70     CONTINUE
   80    CONTINUE
         IF (NBAS.NE.0) THEN
           CALL DIAGGE(NDH,NBAS,HAM,OVER,EVAL,SC1,1)
           NEIG=NBAS
C
         WRITE(97,*)'REP: ',IREP,' DIM: ',NDMREP(IREP),
     &              ' NUMBER OF BASES: ',NBAS
         WRITE(98,*)'REP: ',IREP,' DIM: ',NDMREP(IREP),
     &              ' NUMBER OF BASES: ',NBAS
          N_VIRT(IREP,ISPN)=NEIG
          NVIRTTOT=NVIRTTOT+NEIG
          WRITE(97,*)NDMREP(IREP),NEIG
          WRITE(97,1300)(EVAL(IEIG),IEIG=1,NEIG)
          WRITE(98,*)NDMREP(IREP),NEIG
          WRITE(98,1300)(EVAL(IEIG),IEIG=1,NEIG)
 1300     FORMAT(' ',5G15.7)
         END IF
C
C STORE ALL EIGENVECTORS THAT FIT INTO PSI_COEF
C
         NSAV(IREP,ISPN)=MIN(NEIG,MAX_VIRT_PER_SYM)
         DO 120 ISAV=1,NSAV(IREP,ISPN)
           IF(ISAV.LE.N_OCC(IREP,ISPN))THEN
              L=L+1
              TRACE=TRACE+OCCUPANCY(L)*EVAL(ISAV)*NDMREP(IREP)
           EVALSAV(L)=EVAL(ISAV)
           OCCTMP (L)=OCCUPANCY(L)
           NDEG   (L)=NDMREP(IREP)
           INDREP (L)=IREP
           NTEMP  (L)=ISPN
           END IF
          DO 110 IB=1,NBAS
           PSI_COEF(IB,ISAV,IREP,ISPN)=HAM(IB,ISAV)
  110     CONTINUE
  120    CONTINUE
  130   CONTINUE
        IF(ISPN.EQ.1) NVIRT_UP=NVIRTTOT
  240  CONTINUE
        ISAV=0
        IOFS=0
        JVIRT=0
        KVIRT=0
        DO ISPN=1,NSPN
        ELEC=0.0D0
        DO 200 IREP=1,N_REP
         DO 190 IVIRT=1,N_OCC(IREP,ISPN)
          KVIRT=KVIRT+1
          ELEC=ELEC+OCCTMP(KVIRT)*NDEG(KVIRT)
          DO 180 IDEG=1,NDMREP(IREP)
           NWF=NWF+1
           NWFS(ISPN)=NWFS(ISPN)+1
           IF (NWF .GT. MAX_OCC) THEN
            CALL STOPIT
           ELSE
            EVLOCC(NWF)=EVALSAV(KVIRT)
           END IF
  180     CONTINUE
  190    CONTINUE
         N_VIRT(IREP,ISPN)=NSAV(IREP,ISPN)
  200   CONTINUE
        IF (ISAV .NE. 0) THEN
         PRINT *,'NEWWAVE: MAX_OCC MUST BE AT LEAST ',ISAV
         CALL STOPIT
        END IF
       ENDDO
       Write(6,*)'ELECTRON :',E_UP,E_DN
C
C SORT EIGENVALUES
C
        DO 220 ISORT=1,L
         DO 210 JSORT=ISORT+1,L
          IF (EVALSAV(JSORT).LT.EVALSAV(ISORT)) THEN
           CALL SWAP(EVALSAV(ISORT),EVALSAV(JSORT))
           CALL SWAP(OCCTMP(ISORT),OCCTMP(JSORT))
           CALL ISWAP(NDEG(ISORT),NDEG(JSORT))
           CALL ISWAP(INDREP(ISORT),INDREP(JSORT))
           CALL ISWAP(NTEMP(ISORT),NTEMP(JSORT))
          END IF
  210    CONTINUE
  220   CONTINUE
C
C OUTPUT
C
        WRITE(6,*)'ELECTRONS OF SPIN UP : ', E_UP
        WRITE(6,*)'ELECTRONS OF SPIN DN : ', E_DN
        WRITE(97,*)'FERMI LEVEL: ',EF,' TEMP: ',TEMP
        WRITE(97,*)'SUMMARY OF EVALUES AND THEIR OCCUPANCIES:'
        WRITE(98,*)'FERMI LEVEL: ',EF,' TEMP: ',TEMP
        WRITE(98,*)'SUMMARY OF EVALUES AND THEIR OCCUPANCIES:'
        ECUT=MAX(0.0D0,EF+2.0D1*TEMP)
        DO 230 IOCC=1,L
         WRITE(97,1500) IOCC,INDREP(IOCC),NDEG(IOCC),NTEMP(IOCC),
     &                  EVALSAV(IOCC),OCCTMP(IOCC)
         WRITE(98,1500) IOCC,INDREP(IOCC),NDEG(IOCC),NTEMP(IOCC),
     &                  EVALSAV(IOCC),OCCTMP(IOCC)
         IF (EVALSAV(IOCC).GT.ECUT) GOTO 290
  230   CONTINUE
  290  CONTINUE
 1500  FORMAT(I5,2X,'REP: ',I2,2X,'DEG: ',I2,2X,'SPIN: ',I2,2X,
     &'ENERGY: ',  G14.6,2X,'OCC: ',G14.6)
       ISPFAC=2/NSPN
       TRACE=TRACE*ISPFAC
       CLOSE(97)
       CLOSE(98)
       CALL GTTIME(TIME2)
       CALL TIMOUT('CONSTRUCTION OF NEW WAVEFUNCTIONS: ',TIME2-TIME1)
       RETURN
       END
