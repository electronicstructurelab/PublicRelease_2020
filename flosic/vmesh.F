C UTEP Electronic Structure Lab (2020)
      SUBROUTINE VMESH(ITBEG,ICALC)
C
C     ORIGINAL VERSION BY MARK R PEDERSON JULY 1989
C
C     ------------------------------------------------------------------
C
       use global_inputs,only : SOLVENT1,MOLDEN1
       use xmol,only : AU2ANG,NUM_ATMS,XMOL_LIST,GET_LETTER
       use mesh1,only : wmsh,rmsh,nmsh
       use debug1
       use common1,only : ALPCOR
       use common2,only : RIDT, IFUIDT, NIDENT, ZNUC, BFALP,
     &   N_BARE, MOVING, NATOMS, MOLDEN
       use common3,only : RMAT, NGRP
       use common8,only : REP
       use mpidat1,only : NPROC, NCALLED
       use istitl
! Conversion to implicit none.  Raja Zope Sun Aug 20 09:02:00 MDT 2017

!      INCLUDE  'PARAMAS'  
       INCLUDE  'PARAMA2'  
       INTEGER :: ITBEG, ICALC, MXANG, MXCUBE, I, IADD, IALP, IANP,
     & IATOM, IB, IBOX, IBX, IC, ICHANGE, ICUBE, IDEG, IEND, IERR,
     & IFNCT, IFOUND, IGRP, II1, II2, IID, IIDENT, IM1, IMESH,
     & INUC, IPM, IPTS, IR, IRZ, ISAV, ISTART, ISW, ITRAF, ITRY, ITYP,
     & IX, IY, IZ, J, JB, JBOX, JBX, JC, JCALC, JCUBE, JR, JTYP, JX, K,
     & KADD, KB, KC, KCUBE, KFULL, KPERM, LMXA, MXRZON, MXTYP, MBOX,
     & MSHSLV, MSITES, MSTART, MXCPTS, MXP1D, MXRAD, MXZCHG, N1,
     & N2, NADD, NALTST, NATOM, NBOX, NCREAT, NCTOT, NCUBE, NDEG, NEQV,
     & NFOUND, NGFULL, NGPERM, NNBOX, NNEW, NPATS, NPHI, NPIST,
     & NPMAX, NPOLY, NR1, NR2, NRAD, NRZONE, NSAVP, NSITES, NSPC,
     & NTHET, NTID, NTOTAL, NTRAF, NTYP, NUNIQUE, NZ

       REAL*8 :: SYMBOL , ACCU, ADD, AFUDAT, AFUDGE, ALBS,
     & ALP, ALWS, AMAX, AMIN, ANGLE, ATMP, AVG, BETA, BOX,
     & BOXD2, BOXDM, COREX, CORSPH, CUBE, CUTFAC, DALLOW, DCLOS, DIF,
     & DIST, DMAX, DOMEGA, EBST, EMIN, ERRAT, ERRBOX, ERRIS, ERROR,
     & ERRSPH, EWST, EXACT, EXPECTED, GAIN, PI, POTF, PSPH, RAFUDIS,
     & RALLOW, RATIO, RBOX, RBUF, RCOMP2, RCUTS, RHOF, RIDENT, RINFTY,
     & RMIN, RNEWIDT, RSPH, RTMP, RZON, SDIST, SPLRAT, SPLRAT2,
     & SUM, TIME1, TIME2, TIME3, TIME4, TOLER, VBOX, VCUB, VEXCL,
     & VINNER, VLDA, VLDAM, VOL, VOLSPH, VOLTL, VOLUM, VTOT, WBUF, X,
     & X1, X2, XLEFT, XRIGHT, XXX, YYY, Z, ZAT, ZZON, ZZZ
        SAVE
C
C MXRZON: MAX. NUMBER OF RADIAL ZONES FOR ATOMIC SPERES
C MXTYP:  MAX. NUMBER OF DIFFERENT ATOM TYPES
C MXCUBE: MAX. NUMBER OF CUBES
C MXRAD:  MAX. NUMBER OF POINTS FOR A RADIAL MESH
C MXCPTS: MAX. NUMBER OF INEQIV. POINTS FOR AN ATOMIC CUBE
C MXANG:  MAX. NUMBER OF ANGULAR POINTS FOR AN ATOMIC SPHERE
C MSHSLV: MINIMUM NUMBER OF WORKERS FOR WHICH MANAGER DOES ONLY SETUP
C
        PARAMETER (MXZCHG=100)
        PARAMETER (MXRZON=6)
        PARAMETER (MXTYP=5)
        PARAMETER (MXCUBE=100*MX_CNT)
        PARAMETER (MXRAD=2000)  !changed 200 -> 700 (Sept Mesh) -> 2000 (Oct Mesh) YY
        PARAMETER (MXCPTS=2000) !changed 400 -> 700 (Sept Mesh) -> 2000 (Oct Mesh) YY
        PARAMETER (MXANG=400) !DFT:200 SIC:400
        PARAMETER (MSHSLV=4)
        LOGICAL INBOX,EXIST,FIXIT,OK,LSYWT
!        COMMON/ISTITL/RNUC(3,MX_CNT),ZALP(2,MX_CNT),AFUDIS,ALONG
!     &  ,IFNU(MX_CNT),NPOW(MX_CNT),NNUC,MX1D

C
C SCRATCH COMMON BLOCK FOR LOCAL ARRAYS
CJUR
        CHARACTER*2  :: LETTER
CJUR
        REAL*8,ALLOCATABLE :: BCUT(:,:),PLANE(:,:,:)
     &   ,SIDE(:,:,:),XSLICE(:),XSEP(:),RRAD(:),WRAD(:)
     &   ,RSQVOL(:,:),BOXMOL(:,:),ALMIN(:),ALMAX(:)
        INTEGER,ALLOCATABLE :: NSYMOP(:),NORIG(:),IFSPL(:)
     &   ,ISLICE(:),NUMBOX(:)
        INTEGER :: NXPT(3),NFBUF(8)
        LOGICAL,ALLOCATABLE :: CATOM(:)
        real*8 :: RCUTOFF, SPLITHERE ! external function - RRZ
C        COMMON/TMP2/BCUT(3,MX_CNT+8),PLANE(2,3,MXCUBE)
C     &   ,SIDE(2,3,MXCUBE),XSLICE(3*MX_CNT)
C     &   ,XSEP(MX_CNT+2),RRAD(MXRAD),WRAD(MXRAD)
C     &   ,RSQVOL(2,MXCUBE),BOXMOL(3,2)
C     &   ,ALMIN(MAX_IDENT),ALMAX(MAX_IDENT)
C     &   ,NXPT(3),ISLICE(3*MX_CNT),NUMBOX(MXCUBE)
C     &   ,NFBUF(8),NSYMOP(MX_GRP),NORIG(MXCUBE)
C     &   ,CATOM(MXCUBE),IFSPL(MX_CNT+2)
C
        DIMENSION RBUF(3,MXCPTS),WBUF(MXCPTS)
     &   ,ZZON(MXTYP),RZON(MXRZON)
     &   ,BOX(2,3),ANGLE(3,MXANG),DOMEGA(MXANG)
     &   ,RIDENT(3,MX_GRP),RNEWIDT(3,MX_CNT),CUBE(3,MXCUBE)
     &   ,NPATS(MXTYP),NPIST(MXTYP)
     &   ,LMXA(MXRZON,MXTYP),NPHI(MXTYP),NTHET(MXTYP),MSITES(1)
C
        DATA LSYWT/.FALSE./
!DFT
!        DATA ERRAT,AFUDAT/1.0D-6, 1.2D0/
!SIC
        DATA ERRAT,AFUDAT/1.0D-7, 1.2D0/
        DATA NRZONE/6/
        DATA RZON/ 0.2D0, 0.4D0, 0.6D0, 1.0D0, 1.6D0, 1000.0D0/
        DATA NTYP/ 4/
        DATA ZZON/ 2.1D0, 10.1D0, 18.1D0, 0.0D0, 0.0D0/
        DATA NPATS/2,  4,  4,  6,  0/
        DATA NPIST/1,  1,  1,  1,  0/
        DATA NTHET/3,  3,  3,  3,  0/
        DATA NPHI/ 5,  5,  6,  6,  0/
!DFT
!        DATA LMXA/ 5,7,9,11,15,19, 5,7,9,11,15,19,
!     &             5,7,9,11,15,19, 7,7,9,11,15,19,  6*0/
!SIC
        DATA LMXA/15,15,15,25,25,25, 25,25,25,25,25,25,
     &            25,25,25,25,25,25, 25,25,25,25,25,25, 6*0/ 
!DFT
!        DATA ERRIS,RAFUDIS/2.0D-6, 1.2D0/
!SIC
        DATA ERRIS,RAFUDIS/1.0D-7, 1.2D0/
        DATA CUTFAC,MXP1D/2.0D0, 8/
        DATA SPLRAT/2.0D0/
C
C     --- TOLER IS A GENERAL ACCURACY MARGIN. ---
C     --- VOLTL IS THE VOLUME ACCURACY MARGIN. ---
C
        DATA TOLER/1.0D-8/
        DATA VOLTL/1.0D-10/
C
C     ------------------------------------------------------------------
C
C     --- CHECK IF VMOLD EXISTS AND READ OLD MESH IF DESIRED ---
C
      PRINT '(A)',' '
      PRINT '(A)','CREATING VARIATIONAL INTEGRATION MESH'
C
C     --- ALLOCATE LOCAL ARRAYS ---
C
      ALLOCATE(BCUT(3,MX_CNT+8),STAT=IERR)
      IF(IERR/=0)WRITE(6,*)'VMESH:ERROR ALLOCATING BCUT'
      ALLOCATE(PLANE(2,3,MXCUBE),STAT=IERR)
      IF(IERR/=0)WRITE(6,*)'VMESH:ERROR ALLOCATING PLANE'
      ALLOCATE(SIDE(2,3,MXCUBE),STAT=IERR)
      IF(IERR/=0)WRITE(6,*)'VMESH:ERROR ALLOCATING SIDE'
      ALLOCATE(XSLICE(3*MX_CNT),STAT=IERR)
      IF(IERR/=0)WRITE(6,*)'VMESH:ERROR ALLOCATING XSLICE'
      ALLOCATE(XSEP(MX_CNT+2),STAT=IERR)
      IF(IERR/=0)WRITE(6,*)'VMESH:ERROR ALLOCATING XSEP'
      ALLOCATE(RRAD(MXRAD),STAT=IERR)
      IF(IERR/=0)WRITE(6,*)'VMESH:ERROR ALLOCATING RRAD'
      ALLOCATE(WRAD(MXRAD),STAT=IERR)
      IF(IERR/=0)WRITE(6,*)'VMESH:ERROR ALLOCATING WRAD'
      ALLOCATE(RSQVOL(2,MXCUBE),STAT=IERR)
      IF(IERR/=0)WRITE(6,*)'VMESH:ERROR ALLOCATING RSQVOL'
      ALLOCATE(BOXMOL(3,2),STAT=IERR)
      IF(IERR/=0)WRITE(6,*)'VMESH:ERROR ALLOCATING BOXMOL'
      ALLOCATE(ALMIN(MAX_IDENT),STAT=IERR)
      IF(IERR/=0)WRITE(6,*)'VMESH:ERROR ALLOCATING ALMIN'
      ALLOCATE(ALMAX(MAX_IDENT),STAT=IERR)
      IF(IERR/=0)WRITE(6,*)'VMESH:ERROR ALLOCATING ALMAX'
      ALLOCATE(ISLICE(3*MX_CNT),STAT=IERR)
      IF(IERR/=0)WRITE(6,*)'VMESH:ERROR ALLOCATING ISLICE'
      ALLOCATE(NUMBOX(MXCUBE),STAT=IERR)
      IF(IERR/=0)WRITE(6,*)'VMESH:ERROR ALLOCATING NUMBOX'
      ALLOCATE(NSYMOP(MX_GRP),STAT=IERR)
      IF(IERR/=0)WRITE(6,*)'VMESH:ERROR ALLOCATING NSYMOP'
      ALLOCATE(NORIG(MXCUBE),STAT=IERR)
      IF(IERR/=0)WRITE(6,*)'VMESH:ERROR ALLOCATING NORIG'
      ALLOCATE(CATOM(MXCUBE),STAT=IERR)
      IF(IERR/=0)WRITE(6,*)'VMESH:ERROR ALLOCATING CATOM'
      ALLOCATE(IFSPL(MX_CNT+2),STAT=IERR)
      IF(IERR/=0)WRITE(6,*)'VMESH:ERROR ALLOCATING IFSPL'

      allocate(RNUC(3,MX_CNT))
      allocate(ZALP(2,MX_CNT))
      allocate(IFNU(MX_CNT))
      allocate(NPOW(MX_CNT))
C
        TIME2=TIME1
        TIME3=TIME1
        IF (ITBEG.NE.0) THEN
         IF (ITBEG.LT.0) ITBEG=0
         INQUIRE(FILE='VMOLD',EXIST=EXIST)
         IF (EXIST) THEN
          PRINT '(A)','TRYING TO READ OLD MESH'
          OPEN(99,FILE='VMOLD',FORM='UNFORMATTED',STATUS='UNKNOWN')
          REWIND(99)
          READ(99) NMSH,JCALC
          PRINT '(A,I10)','TOTAL NUMBER OF MESH POINTS: ',NMSH
          IF (NMSH.GT.MAX_PTS) THEN
           write(6,*)'VMESH: MAX_PTS MUST BE AT LEAST: ',NMSH
           CALL STOPIT
          END IF
          READ(99)((RMSH(J,I),J=1,3),I=1,NMSH)
          READ(99)(WMSH(I),I=1,NMSH)
          CLOSE(99)
          IF (JCALC.EQ.ICALC) THEN
           CALL GTTIME(TIME2)
           CALL REORMSH
           CALL GTTIME(TIME3)
c
c mpi: send mesh to all nodes
c
#ifdef MPI
c
        CALL SENDDATA(102)
c
#endif
c
           CALL CHECK_INPUTS
           IF(MOLDEN1)THEN
             !CALL MOLDENDRV("XYZ")
           ENDIF
           GOTO 900
          END IF
          write(6,*)'VMESH: VMOLD IS INCOMPATIBLE WITH CURRENT GEOMETRY'
          write(6,*)'       A NEW MESH WILL BE CREATED'
          write(6,*)'       OLD MESH WILL BE STORED IN FILE VMSAV'
          OPEN(99,FILE='VMSAV',FORM='UNFORMATTED',STATUS='UNKNOWN')
          WRITE(99) NMSH,JCALC
          WRITE(99)((RMSH(J,I),J=1,3),I=1,NMSH)
          WRITE(99)(WMSH(I),I=1,NMSH)
          CLOSE(99)
         END IF
        END IF
        PI=4*ATAN(1.0D0)
C
C READ MESHDAT
C
        OPEN(99,FILE='MESHDAT',FORM='FORMATTED',STATUS='UNKNOWN')
        REWIND(99)
        READ(99,*,END=10) LSYWT
        READ(99,*,END=10) ERRAT,AFUDAT
        READ(99,*,END=10) NRZONE
        IF (NRZONE.GT.MXRZON) THEN
         write(6,*)'VMESH: MXRZON MUST BE AT LEAST: ',NRZONE
         CALL STOPIT
        END IF
        READ(99,*,END=10)(RZON(IRZ),IRZ=1,NRZONE-1)
        RZON(NRZONE)=1000.0D0
        READ(99,*,END=10) NTYP
        IF (NTYP.GT.MXTYP) THEN
         write(6,*)'VMESH: MXTYP MUST BE AT LEAST: ',NTYP
         CALL STOPIT
        ELSE IF (NTYP.LT.1) THEN
         write(6,*)'VMESH: NTYP IS < 1'
         CALL STOPIT
        END IF
        IF (NTYP.GT.1) THEN
         READ(99,*,END=10)(ZZON(ITYP),ITYP=1,NTYP-1)
        END IF
        DO ITYP=1,NTYP
         READ(99,*,END=10) NPATS(ITYP),NPIST(ITYP),NTHET(ITYP),
     &                     NPHI(ITYP),(LMXA(IRZ,ITYP),IRZ=1,NRZONE)
        END DO
        READ(99,*,END=10) ERRIS,RAFUDIS
        READ(99,*,END=10) CUTFAC,MXP1D
        READ(99,*,END=10) SPLRAT
   10   CONTINUE
        AFUDIS=RAFUDIS
        MX1D=MXP1D
        RZON(NRZONE)=1000.0D0
        IF (MX1D   .LT. 1)     MX1D=1
        IF (AFUDAT .LT. 1.1D0) AFUDAT=1.1D0
        IF (AFUDIS .LT. 1.1D0) AFUDIS=1.1D0
        IF (SPLRAT .LE. 1.0D0) SPLRAT=1.0D0
C
C WRITE MESHDAT
C
        REWIND(99)
        WRITE(99,'(1X,L5)') LSYWT
        WRITE(99,'(2(1X,G12.5))') ERRAT,AFUDAT
        WRITE(99,'(1X,I3)') NRZONE
        WRITE(99,'(5(1X,G12.5))')(RZON(IRZ),IRZ=1,NRZONE-1)
        WRITE(99,'(1X,I3)') NTYP
        IF (NTYP.GT.1) THEN
         WRITE(99,'(5(1X,G12.5))')(ZZON(ITYP),ITYP=1,NTYP-1)
        END IF
        DO ITYP=1,NTYP
         WRITE(99,'(20(1X,I3))') NPATS(ITYP),NPIST(ITYP),NTHET(ITYP),
     &                           NPHI(ITYP),
     &                           (LMXA(IRZ,ITYP),IRZ=1,NRZONE)
        END DO
        WRITE(99,'(2(1X,G12.5))') ERRIS,AFUDIS
        WRITE(99,'(1X,G12.5,1X,I3)') CUTFAC,MX1D
        WRITE(99,'(1X,G12.5)') SPLRAT
        WRITE(99,*) '------------------------------------------------'
        WRITE(99,*) '* LSYWT'
        WRITE(99,*) '* ERRMAX, ALFUDGE FOR ATOMIC CUBES'
        WRITE(99,*) '* NUMBER OF RADIAL ZONES INSIDE ATOM SPHERES'
        WRITE(99,*) '* OUTER RADII OF SPHERE ZONES'
        WRITE(99,*) '* NUMBER OF ATOM TYPES (NTYP)'
        WRITE(99,*) '* UPPER NUCLEAR CHARGE LIMIT FOR EACH ATOM TYPE'
        WRITE(99,*) '* NPATS, NPIST, NTHET, NPHI, LMAX FOR'
        WRITE(99,*) '  EACH RADIAL ZONE (NTYP LINES)'
        WRITE(99,*) '* INTERSTITIALS: ERRMAX, ALFUDGE'
        WRITE(99,*) '* CUTFAC: IF A BOX TRANSFORMS INTO ITSELF DUE TO'
        WRITE(99,*) '  SYMMETRY, IT WILL BE SPLIT IF IT IS LARGER THAN'
        WRITE(99,*) '  CUTFAC TIMES THE DISTANCE TO THE CLOSEST ATOM'
        WRITE(99,*) '  MX1D: MAX. NUMBER OF POINTS IN A'
        WRITE(99,*) '  ONE-DIMENSIONAL INTERSTITIAL PARTITION'
        WRITE(99,*) '* SPLRAT: LARGEST ALLOWED RATIO FOR: THE SIZE OF'
        WRITE(99,*) '  AN ATOMIC BOX DEVIDED BY THE DISTANCE OF ANOTHER'
        WRITE(99,*) '  ATOM TO THE BOX BOUNDARY'
        CLOSE(99)
C
C CHECK ORDERING OF RZON AND ZZON
C
        DO IRZ=2,NRZONE-1
         IF (RZON(IRZ).LT.RZON(IRZ-1)) THEN
          write(6,*)'VMESH: ORDER RZON IN MESHDAT SMALL -> BIG'
          CALL STOPIT
         END IF
        END DO
        DO ITYP=2,NTYP-1
         IF (ZZON(ITYP).LT.ZZON(ITYP-1)) THEN
          write(6,*)'VMESH: ORDER ZZON IN MESHDAT SMALL -> BIG'
          CALL STOPIT
         END IF
        END DO
C
C PRINT IDENTITY MEMBERS
C INITIALIZE RNEWIDT,NORIG,ALMIN,ALMAX
C DETERMINE MINIMUM AND MAXIMUM EXPONENTS
C
        IF (NIDENT .GT. MX_CNT) THEN
         write(6,*)'VMESH: MX_CNT MUST BE AT LEAST: ',NIDENT
         CALL STOPIT
        END IF
        ALONG=1.0D30
        PRINT '(A)','ORIGINAL IDENTITY MEMBERS:'
        DO IID=1,NIDENT
         PRINT 1010,IID,(RIDT(I,IID),I=1,3),ZNUC(IFUIDT(IID))
 1010    FORMAT('ATOM ',I3,':',3(1X,F12.6),', Z= ',F10.5)
         NZ=NINT(ZNUC(IFUIDT(IID)))
         IF (NZ .GT. MXZCHG) THEN
          write(6,*)'VMESH: MXZCHG MUST BE AT LEAST: ',NZ
          CALL STOPIT
         END IF
         IF (NZ .LT. 0) THEN
          write(6,*)'VMESH: NUCLEAR CHARGE LESS THAN ZERO'
          CALL STOPIT
         END IF
         DO I=1,3
          RNEWIDT(I,IID)=RIDT(I,IID)
         END DO
         NORIG(IID)=IID
         IFNCT=IFUIDT(IID)
         IF (N_BARE(IFNCT) .LE. 0) THEN
          write(6,*)'VMESH: FOUND REAL ATOM WITHOUT ANY BASIS FUNCTIONS'
          CALL STOPIT
         END IF
         AMIN=BFALP(1,IFNCT)
         AMAX=BFALP(1,IFNCT)
         DO I=1,N_BARE(IFNCT)
          AMIN=MIN(AMIN,ABS(BFALP(I,IFNCT)))
          AMAX=MAX(AMAX,ABS(BFALP(I,IFNCT)))
         END DO
         ALONG=MIN(ALONG,AMIN)
         AMAX=2*AMAX+MAX(2*AMAX,ALPCOR(IFNCT))
         ALMIN(IID)=AMIN
         ALMAX(IID)=AMAX
        END DO
        IF (ALONG .LT. 1.0D-3) THEN !YY Changed 1.0D-4 -> 1.0D-3
         write(6,*)'VMESH: SMALLEST EXPONENT IS TOO SMALL: ',ALONG
         CALL STOPIT
        END IF
C
C IF PERMUTATION MATRICES DO NOT APPEAR FIRST IN GRPMAT THEN STOP
C
        OK=.TRUE.
        NGPERM=0
        DO 20 IGRP=1,NGRP
         ADD=0.0D0
         DO I=1,3
          DO J=1,3
           ADD=ADD+ABS(RMAT(J,I,IGRP))
          END DO
         END DO
         IF (ADD.LT.(3.0D0+TOLER)) THEN
          NGPERM=NGPERM+1
          IF (.NOT.OK) THEN
           write(6,*)'VMESH: X/Y/Z PERMUTATION MATRICES MUST APPEAR'
           write(6,*)'FIRST IN GRPMAT. PLEASE REORDER.'
           CALL STOPIT
          END IF
         ELSE
          OK=.FALSE.
         END IF
   20   CONTINUE
C
C CHECK IF WE HAVE TO ADD MORE IDENTITY MEMBERS 
C
        NGFULL=NGRP
        FIXIT=.FALSE.
        IF (NGPERM.LT.NGRP) FIXIT=.TRUE.
C
C CHECK TO SEE IF ANY MORE 'IDENTITIES' NEED TO BE ADDED IF
C USING A SMALLER GROUP 
C
        IF ((NGFULL+NGPERM).GT.MXCUBE) THEN
         write(6,*)'VMESH: MXCUBE MUST BE AT LEAST: ',NGFULL+NGPERM
         CALL STOPIT
        END IF
        NUNIQUE=NIDENT
        IF (FIXIT) THEN
         DO 60 ICUBE=1,NIDENT
          NGRP=NGFULL
          CALL GASITES(1,RNEWIDT(1,ICUBE),KFULL,CUBE,MSITES)
          NGRP=NGPERM
          CALL GASITES(1,RNEWIDT(1,ICUBE),KPERM,CUBE(1,KFULL+1),MSITES)
C
C ADD IDENTITY MEMBERS
C
          IF (KPERM.LT.KFULL) THEN
           DO 40 JCUBE=1,KFULL
            EMIN=1.0D30
            DO KCUBE=1,KPERM
             ERROR=ABS(CUBE(1,KCUBE+KFULL)-CUBE(1,JCUBE))+
     &             ABS(CUBE(2,KCUBE+KFULL)-CUBE(2,JCUBE))+
     &             ABS(CUBE(3,KCUBE+KFULL)-CUBE(3,JCUBE))
             IF (ERROR.LT.EMIN) EMIN=ERROR
            END DO
            IF (EMIN.GT.TOLER) THEN
             NUNIQUE=NUNIQUE+1
             IF (NUNIQUE.GT.MX_CNT) THEN
              write(6,*)'VMESH: MX_CNT MUST BE AT LEAST: ',NUNIQUE
              CALL STOPIT
             END IF
             RNEWIDT(1,NUNIQUE)=CUBE(1,JCUBE)
             RNEWIDT(2,NUNIQUE)=CUBE(2,JCUBE)
             RNEWIDT(3,NUNIQUE)=CUBE(3,JCUBE)
             NORIG(NUNIQUE)=NORIG(ICUBE)
             IF (DEBUG) THEN
              PRINT 8010,'ADDED IDENT:',(RNEWIDT(J,NUNIQUE),J=1,3)
             END IF
             CALL GASITES
     &        (1,RNEWIDT(1,NUNIQUE),KADD,CUBE(1,KFULL+KPERM+1),MSITES)
             KPERM=KPERM+KADD
             IF (KPERM.EQ.KFULL) GOTO 50
            END IF
   40      CONTINUE
           write(6,*)'VMESH: LOGICAL ERROR, BUG SUSPECTED'
           CALL STOPIT
   50      CONTINUE
          END IF
   60    CONTINUE
        END IF
C
C SETUP NPMAX, NGRP, NNUC, CUBE, NORIG, AND NPOW FOR SPACE PARTITIONING
C
        NGRP=NGPERM
        NNUC=0
        NPMAX=0
        DO 70 ICUBE=1,NUNIQUE
         NSPC=NNUC+NGPERM+NUNIQUE-ICUBE
         IF (NSPC.GT.MXCUBE) THEN
          write(6,*)'VMESH: MXCUBE MUST BE AT LEAST: ',NSPC
          CALL STOPIT
         END IF
         Z=ABS(ZNUC(IFUIDT(NORIG(NNUC+1))))
         ITYP=NTYP
         DO JTYP=NTYP-1, 1, -1
          IF (Z.LE.ZZON(JTYP)) ITYP=JTYP
         END DO
         NPMAX=MAX(NPMAX,NPATS(ITYP))
         NPMAX=MAX(NPMAX,NPIST(ITYP))
C
C GET ALL EQUIVALENT ATOMS, UPDATE NORIG AND CUBE
C
         CALL GASITES
     &    (1,RNEWIDT(1,ICUBE),KCUBE,CUBE(1,NNUC+1),MSITES)
         DO JCUBE=NUNIQUE-ICUBE,1,-1
          NORIG(NNUC+KCUBE+JCUBE)=NORIG(NNUC+1+JCUBE)
         END DO
         DO JCUBE=NNUC+1,NNUC+KCUBE
          NPOW(JCUBE)=MAX(NPIST(ITYP),0)
          NORIG(JCUBE)=NORIG(NNUC+1)
         END DO
         NNUC=NNUC+KCUBE
   70   CONTINUE
C
CJUR
C SAVE TOTAL NUMBER OF ATOMS
C
        NATOMS = NNUC
CJUR
C        WRITE(*,*) 'NATOMS IN VMESH ARE:',NATOMS
CJUR
C WRITE XYZ STRUCTURE FILE WHICH IS XMOL READABLE
C
        OPEN(99,FILE='XMOL.DAT',FORM='FORMATTED',STATUS='UNKNOWN')
        REWIND(99)
        WRITE(99,'(I5)') NNUC
        WRITE(99,'(A)') 'Cluster output'
        NUM_ATMS=NNUC
! needed for FODONMSH. cmd
        IF(ALLOCATED(XMOL_LIST)) DEALLOCATE(XMOL_LIST)
!
        ALLOCATE(XMOL_LIST(NNUC),STAT=IERR)
        IF(IERR.NE.0)WRITE(6,*)'VMESH:ERROR ALLOCATING XMOL_LIST'
        DO INUC=1,NNUC
         WRITE(99,'(1X,I4,3(1X,F10.5))')
     &    NINT(ZNUC(IFUIDT(NORIG(INUC)))),(AU2ANG*CUBE(I,INUC), I=1,3)
          XMOL_LIST(INUC)%ANUM=NINT(ZNUC(IFUIDT(NORIG(INUC))))
          XMOL_LIST(INUC)%RX=CUBE(1,INUC)
          XMOL_LIST(INUC)%Ry=CUBE(2,INUC)
          XMOL_LIST(INUC)%Rz=CUBE(3,INUC)
        END DO
        CLOSE(99)
C
C WRITE XYZ STRUCTURE FILE WHICH IS JMOL AND MOLEKEL READABLE
C
        OPEN(99,FILE='XMOL.xyz',FORM='FORMATTED',STATUS='UNKNOWN')
        REWIND(99)
        WRITE(99,'(I5)') NNUC
        WRITE(99,'(A)') 'Cluster output'
        DO INUC=1,NNUC 
          CALL GET_LETTER(NINT(ZNUC(IFUIDT(NORIG(INUC)))),LETTER)
          WRITE(99,'(1X,A,3(1X,F10.5))')
     &      LETTER,(AU2ANG*CUBE(I,INUC), I=1,3)
        END DO
        CLOSE(99)
C
C     --- WRITE XYZ STRUCTURE TO THE ATOMS SECTION OF MOLDEN OUTPUT FILE
C
      CALL CHECK_INPUTS
      IF(MOLDEN1)THEN
        IF (MOLDEN.NE.'NONE') THEN
          NGRP=NGFULL
          !CALL MOLDENDRV("XYZ")
          NGRP=NGPERM
        END IF
      ENDIF
C
C     ---  DETERMINE INFINITY RADIUS ---
C
        RINFTY= 0.1D0*ERRIS
        RINFTY= RCUTOFF(NPMAX+2,2*ALONG,RINFTY)
!YY commented out
!        RINFTY=200.0d0
        CALL CHECK_INPUTS
        IF(SOLVENT1) THEN
           WRITE(6,*)'SOLVENT CALCULATION REQUESTED'
           WRITE(6,*)'INIFITY RADIUS SET TO 200'
           RINFTY=200.0d0
C LB : THIS NUMBER ABOVE MAY NEED TO BE ADJUSTED
        ENDIF
        PRINT '(A,F11.2)','INFINITY RADIUS IS: ',RINFTY
C
C PRINT ATOM COORDINATES AND DEFINE BOUNDING BOX
C
        PRINT '(A)',' '
        PRINT '(A,I5)','NUMBER OF UNIQUE ATOMS: ',NUNIQUE
        PRINT '(A)',   'COORDINATES OF ATOMIC CUBES:'
        DO I=1,3
         BOXMOL(I,1)=  1.0D30
         BOXMOL(I,2)= -1.0D30
        END DO
        DO 80 ICUBE=1,NNUC
         PRINT 1020,(CUBE(I,ICUBE),I=1,3)
 1020    FORMAT(3(1X,F15.6))
         DO I=1,3
          RNUC(I,ICUBE)=CUBE(I,ICUBE)
          IF (CUBE(I,ICUBE).LT.BOXMOL(I,1)) BOXMOL(I,1)=CUBE(I,ICUBE)
          IF (CUBE(I,ICUBE).GT.BOXMOL(I,2)) BOXMOL(I,2)=CUBE(I,ICUBE)
         END DO
         IFNU(ICUBE)=IFUIDT(NORIG(ICUBE))
         ZALP(1,ICUBE)=ABS(ALMIN(NORIG(ICUBE)))
         ZALP(2,ICUBE)=ABS(ALMAX(NORIG(ICUBE)))
   80   CONTINUE
C
C ADD RINFTY TO THE BOUNDING BOX LIMITS AND GET EXPECTED VOLUME
C
        EXPECTED=1.0D0
        DO I=1,3
         BOXMOL(I,1)=BOXMOL(I,1)-RINFTY
         BOXMOL(I,2)=BOXMOL(I,2)+RINFTY
         EXPECTED=EXPECTED*(BOXMOL(I,2)-BOXMOL(I,1))
        END DO
C
C ASSIGN EACH ATOM TO THE FIRST BOX. SET UP THE FIRST TWO PLANES IN
C X/Y/Z DIRECTION TO BE IDENTICAL TO THE BOUNDING BOX LIMITS.
C INDEXING: PLANE(1/2 FOR LEFT/RIGHT, 1/2/3 FOR X/Y/Z, BOXINDEX)
C CATOM(IBOX) IS TRUE IF BOX IBOX CONTAINS AN ATOM
C
        DO ICUBE=1,NNUC
         NUMBOX(ICUBE)=1
        END DO
        DO IC=1,3
         DO J=1,2
          PLANE(J,IC,1)=BOXMOL(IC,J)
         END DO
        END DO
        CATOM(1)=.TRUE.
C
C START ADDBOX: CHECK EACH BOX FOR THE NUMBER OF ATOMS CONTAINED AND
C SLICE IT IF MORE THAN ONE ATOM IS IN THE BOX
C
        PRINT '(A)',' '
        PRINT '(A)','THE CAKE WILL BE SLICED RIGHT NOW !'
        MBOX=1
C
C BEGIN OF BOX LOOP
C
  110   CONTINUE
         NBOX=MBOX
         IADD=0
         DO 260 IBOX=1,MBOX
C
C GET NUMBER OF ATOMS THAT ARE IN BOX IBOX
C
          NATOM=0
          DO ICUBE=1,NNUC
           IF (NUMBOX(ICUBE).EQ.IBOX) NATOM=NATOM+1
          END DO
C
C SLICE BOX IBOX IF IT CONTAINS MORE THAN ONE ATOM
C
          IF (CATOM(IBOX).AND.(NATOM.GT.1)) THEN
           IADD=IADD+1
C
C FIND BEST PLACE TO SLICE BOX IN EITHER X,Y AND Z DIRECTIONS.
C FOR EACH DIRECTION X/Y/Z WRITE COORDINATES OF BOX ATOMS TO XSEP.
C
           NDEG=0
           DMAX=0.0D0
           DO 150 IC=1,3
            NCUBE=0
            DO 120 ICUBE=1,NNUC
             IF (NUMBOX(ICUBE).EQ.IBOX) THEN
              NCUBE=NCUBE+1
              XSEP(NCUBE)=CUBE(IC,ICUBE)
              IFSPL(NCUBE)=IFUIDT(NORIG(ICUBE))
             END IF
  120       CONTINUE
C
C SORT XSEP SMALL -> BIG
C
            DO 130 ICUBE=1,NCUBE
             DO JCUBE=ICUBE+1,NCUBE
              IF (XSEP(JCUBE).LT.XSEP(ICUBE)) THEN
               CALL SWAP (XSEP (ICUBE),XSEP (JCUBE))
               CALL ISWAP(IFSPL(ICUBE),IFSPL(JCUBE))
              END IF
             END DO
  130       CONTINUE
C
C SEEK FOR THE MAXIMUM DISTANCE OF ATOMS THAT ARE NEIGHBORS WITH RESPECT
C TO THEIR X/Y/Z COORDINATES (THAT IS WHY WE DID THE SORTING). -> DMAX
C NDEG IS THE DEGENERACY OF DMAX (NUMBER OF DIFFERENT POSSIBILITIES TO
C SLICE THE BOX WITH THE SAME DMAX). XSLICE IS THE COORDINATE FOR THE
C CUT, ISLICE IS 1/2/3 IF THE CUT IS A X/Y/Z PLANE, RESPECTIVELY
C
            DO 140 ISAV=1,NCUBE-1
             DIST=XSEP(ISAV+1)-XSEP(ISAV)
             IF (DIST.GT.(DMAX+TOLER)) NDEG=0
             IF ((DIST.GE.(DMAX-TOLER)) .AND. (DIST.GE.TOLER)) THEN
              DMAX=DIST
              NDEG=NDEG+1
              N1=ISAV
              DO ICUBE=ISAV-1,1,-1
               IF (XSEP(ISAV)-XSEP(ICUBE) .LT. TOLER) N1=ICUBE
              END DO
              N2=ISAV+1
              DO ICUBE=ISAV+2,NCUBE
               IF (XSEP(ICUBE)-XSEP(ISAV+1) .LT. TOLER) N2=ICUBE
              END DO
              SUM=0.0D0
              DO ICUBE=N1,ISAV
               DO JCUBE=ISAV+1,N2
                DIST=XSEP(JCUBE)-XSEP(ICUBE)
                IF (DIST .LT. TOLER) THEN
                 SUM=SUM+0.5D0*(XSEP(ICUBE)+XSEP(JCUBE))
                ELSE
                 X=SPLITHERE(IFSPL(ICUBE),IFSPL(JCUBE),DIST)
                 RATIO=X/DIST
                 RALLOW=SPLRAT/(SPLRAT+1.0D0)
                 IF (RATIO .GT.       RALLOW) X=DIST*RALLOW
                 IF (RATIO .LT. 1.0D0-RALLOW) X=DIST*(1.0D0-RALLOW)
                 SUM=SUM+XSEP(ICUBE)+X
                END IF
               END DO
              END DO
              XSLICE(NDEG)=SUM/((ISAV-N1+1)*(N2-ISAV))
              ISLICE(NDEG)=IC
             END IF
  140       CONTINUE
  150      CONTINUE
           IF (NDEG .EQ. 0) THEN
            write(6,*)'VMESH: THERE MUST BE IDENTICAL ATOMS HERE'
            CALL STOPIT
           END IF
C
C FOR EACH DIRECTION X/Y/Z, PUT OLD BOX BOUNDARIES AND POSSIBLE NEW
C BOX BOUNDARIES INTO XSEP. NXPT(IC) STORES THE NUMBER OF OLD AND
C POSSIBLE NEW PLANES IN DIRECTION IC.
C
           DO 180 IC=1,3
            XSEP(1)=PLANE(1,IC,IBOX)
            XSEP(2)=PLANE(2,IC,IBOX)
            NXPT(IC)=2
            DO 160 IDEG=1,NDEG
             IF (ISLICE(IDEG).EQ.IC) THEN
              NXPT(IC)=NXPT(IC)+1
              XSEP(NXPT(IC))=XSLICE(IDEG)
             END IF
  160       CONTINUE
C
C SORT COORDINATES OF SLICE PLANES AND COPY THEM ALL TO BX
C
            DO 170 IX=1,NXPT(IC)
             DO JX=IX+1,NXPT(IC)
              IF (XSEP(JX).LT.XSEP(IX)) CALL SWAP(XSEP(IX),XSEP(JX))
             END DO
             BCUT(IC,IX)=XSEP(IX)
  170       CONTINUE
  180      CONTINUE
C
C ADD NEW BOXES. ALL DEGENARATE BOXES MUST BE ADDED TO PREVENT
C THE SYMMETRY FROM GETTING SCREWED UP. THE NEW PLANES ARE ADDED
C FOR X/Y/Z WHILE THE BOX INDEX IS UPDATED
C NNBOX IS SET UP SO THAT THE OLD BOX SLOT IS FILLED WITH A NEW BOX
C
           NNEW=NBOX+NXPT(1)*NXPT(2)*NXPT(3)
           IF (NNEW.GT.MXCUBE) THEN
            write(6,*)'VMESH: MXCUBE MUST BE AT LEST: ',NNEW
            CALL STOPIT
           END IF
           VTOT=
     &      (PLANE(2,1,IBOX)-PLANE(1,1,IBOX))*
     &      (PLANE(2,2,IBOX)-PLANE(1,2,IBOX))*
     &      (PLANE(2,3,IBOX)-PLANE(1,3,IBOX))
           NBOX=NBOX-1
           DO 230 IB=1,NXPT(1)-1
            DO 220 JB=1,NXPT(2)-1
             DO 210 KB=1,NXPT(3)-1
              NBOX=NBOX+1
              NNBOX=NBOX
              IF (IB*JB*KB.EQ.1) NNBOX=IBOX
              PLANE(1,1,NNBOX)=BCUT(1,IB  )
              PLANE(2,1,NNBOX)=BCUT(1,IB+1)
              PLANE(1,2,NNBOX)=BCUT(2,JB  )
              PLANE(2,2,NNBOX)=BCUT(2,JB+1)
              PLANE(1,3,NNBOX)=BCUT(3,KB  )
              PLANE(2,3,NNBOX)=BCUT(3,KB+1)
              VTOT=VTOT-
     &         (PLANE(2,1,NNBOX)-PLANE(1,1,NNBOX))*
     &         (PLANE(2,2,NNBOX)-PLANE(1,2,NNBOX))*
     &         (PLANE(2,3,NNBOX)-PLANE(1,3,NNBOX))
  210        CONTINUE
  220       CONTINUE
  230      CONTINUE
C
C REASSIGN ATOMS TO THE APPROPRIATE BOX AND UPDATE CATOM
C
           DO JBOX=1,NBOX
            CATOM(JBOX)=.FALSE.
           END DO
           DO 250 JBOX=1,NBOX
            DO 240 ICUBE=1,NNUC
             INBOX=.TRUE.
             DO IC=1,3
              IF (CUBE(IC,ICUBE).LT.PLANE(1,IC,JBOX)) INBOX=.FALSE.
              IF (CUBE(IC,ICUBE).GT.PLANE(2,IC,JBOX)) INBOX=.FALSE.
             END DO
             IF (INBOX) THEN
              NUMBOX(ICUBE)=JBOX
              CATOM(JBOX)=.TRUE.
             END IF
  240       CONTINUE
  250      CONTINUE
          END IF
  260    CONTINUE
C
C CALCULATE THE TOTAL VOLUME OF OUR NEW BOX COLLECTION. UPDATE
C MBOX AND GO BACK TO LABEL 10 IF THERE IS STILL SOMETHING TO DO
C
         VOLUM=0.0D0
         DO IBOX=1,NBOX
          VOLUM=VOLUM+
     &     (PLANE(2,1,IBOX)-PLANE(1,1,IBOX))*
     &     (PLANE(2,2,IBOX)-PLANE(1,2,IBOX))*
     &     (PLANE(2,3,IBOX)-PLANE(1,3,IBOX))
         END DO
         MBOX=NBOX
         IF (DEBUG) THEN
          PRINT 8030,'NBOX, VOLUME, EXPECTED:',NBOX,VOLUM,EXPECTED
         END IF
         IF (IADD.NE.0) GOTO 110
        CONTINUE
C
C END OF BOX LOOP
C
C SETUP OF SIDE FOR ALL BOXES CONTAINING ATOMS. SIDE IS THE DISTANCE 
C BETWEEN AN ATOM AND THE CORRESPONDING BOUNDARY BOX. 
C
        DO 270 ICUBE=1,NNUC
         DO IBOX=1,NBOX
          IF (NUMBOX(ICUBE).EQ.IBOX) THEN
           DO IC=1,3
            DO J=1,2
             SIDE(J,IC,ICUBE)=PLANE(J,IC,IBOX)-CUBE(IC,ICUBE)
            END DO
           END DO
          END IF
         END DO
  270   CONTINUE
C
C FILL ARRAYS CUBE AND SIDE WITH BOXES THAT DO NOT CONTAIN ATOMS
C
        NCUBE=NNUC
        DO 280 IBOX=1,NBOX
         IF (.NOT.CATOM(IBOX)) THEN
          NCUBE=NCUBE+1
          DO IC=1,3
           CUBE(IC,NCUBE)=0.5D0*(PLANE(2,IC,IBOX)+PLANE(1,IC,IBOX)) 
          END DO  
          DO IC=1,3
           DO J=1,2
            SIDE(J,IC,NCUBE)=PLANE(J,IC,IBOX)-CUBE(IC,NCUBE)
           END DO  
          END DO  
         END IF
  280   CONTINUE
        IF (DEBUG) THEN
         write(6,*)' '
         write(6,*)'CURRENT BOX PARAMETERS(1):'
         DO ICUBE=1,NCUBE
          PRINT 8050,'BOX',ICUBE
          PRINT 8010,'CENTER',(CUBE(I,ICUBE), I=1,3)
          PRINT 8010,'LEFT  ',(SIDE(1,I,ICUBE), I=1,3)
          PRINT 8010,'RIGHT ',(SIDE(2,I,ICUBE), I=1,3)
         END DO
        END IF
C
C REPLACE EACH PARALLELPIPED BY A CUBE SURROUNDING EACH ATOM PLUS OTHER
C PARALLELPIPEDS SURROUNDING VOIDS.
C
        DO 340 ICUBE=1,NNUC
C
C CALCULATE VOLUME OF BOX. GET THE SMALLEST DISTANCE FROM THE CENTER
C TO THE BOX BOUNDARY.
C
         RMIN=1.0D30
         VTOT=1.0D0
         DO 290 IC=1,3
          VTOT=VTOT+(SIDE(2,IC,ICUBE)-SIDE(1,IC,ICUBE))
          DO J=1,2
           ATMP=ABS(SIDE(J,IC,ICUBE))
           IF (ATMP.LT.RMIN) RMIN=ATMP
          END DO
  290    CONTINUE
C
C SUBTRACT VOLUME OF ATOMIC CUBE FROM THE TOTAL BOX VOLUME.
C PUT NEW BOX BOUNDARIES INTO BX. UPDATE BOUNDARIES FOR ATOMIC CUBE.
C
         VTOT=VTOT-(2*RMIN)**3
         DO 300 IC=1,3
          BCUT(IC,1)=  SIDE(1,IC,ICUBE)
          BCUT(IC,2)= -RMIN
          BCUT(IC,3)=  RMIN
          BCUT(IC,4)=  SIDE(2,IC,ICUBE)
          SIDE(1,IC,ICUBE)= -RMIN
          SIDE(2,IC,ICUBE)=  RMIN
  300    CONTINUE
C
C WITH THE HELP OF BX, WE HAVE TO UPDATE THE ARRAYS SIDE AND CUBE AS IF
C WE WERE SLICING THE OLD BOX INTO 3 PIECES FOR EACH DIRECTION. WHILE
C DOING THIS, UPDATE NCUBE EXCEPT FOR THE CASE OF THE ATOMIC CUBE.
C IGNORE BOXES WITH ZERO VOLUME
C
         DO 330 IB=1,3
          DO 320 JB=1,3
           DO 310 KB=1,3
            IF (IB*JB*KB.NE.8) THEN
             NCUBE=NCUBE+1
             SIDE(1,1,NCUBE)=BCUT(1,IB  )
             SIDE(2,1,NCUBE)=BCUT(1,IB+1)
             SIDE(1,2,NCUBE)=BCUT(2,JB  )
             SIDE(2,2,NCUBE)=BCUT(2,JB+1)
             SIDE(1,3,NCUBE)=BCUT(3,KB  )
             SIDE(2,3,NCUBE)=BCUT(3,KB+1)
             VOLUM=1.0D0
             DO IC=1,3
              AVG=0.5D0*(SIDE(2,IC,NCUBE)+SIDE(1,IC,NCUBE))
              DIF=0.5D0*(SIDE(2,IC,NCUBE)-SIDE(1,IC,NCUBE))
              VOLUM=VOLUM*DIF*2
              CUBE(IC,NCUBE)=CUBE(IC,ICUBE)+AVG
              SIDE(2,IC,NCUBE)=  DIF
              SIDE(1,IC,NCUBE)= -DIF
             END DO
             VTOT=VTOT-VOLUM
             IF (VOLUM. EQ. 0.0D0) NCUBE=NCUBE-1
            END IF
  310      CONTINUE
  320     CONTINUE
  330    CONTINUE
  340   CONTINUE
C
C CHECK TOTAL VOLUME / PRINT BOX PARAMETERS
C
        VOLUM=0.0D0
        DO ICUBE=1,NCUBE
         VOLUM=VOLUM
     &        +8*SIDE(2,1,ICUBE)*SIDE(2,2,ICUBE)*SIDE(2,3,ICUBE)
        END DO
        IF (DEBUG) THEN
         write(6,*)' '
         write(6,*)'CURRENT BOX PARAMETERS(2):'
         DO ICUBE=1,NCUBE
          PRINT 8050,'BOX',ICUBE
          PRINT 8010,'CENTER',(CUBE(I,ICUBE), I=1,3)
          PRINT 8010,'LEFT  ',(SIDE(1,I,ICUBE), I=1,3)
          PRINT 8010,'RIGHT ',(SIDE(2,I,ICUBE), I=1,3)
         END DO
         PRINT 8040,'TOTAL VOLUME:',VOLUM,'EXPECTED:',EXPECTED
        END IF
C
C CHECK TO SEE IF THERE ARE ADJACENT ATOMS IN CLOSE PROXIMITY TO
C LARGE ATOMIC CUBES
C IF THIS IS THE CASE, MAKE THE LARGE CUBES SMALLER
C (MR Pederson 1997 / DV Porezag 1998)
C
        PRINT '(2A)','CHECKING IF ADJACENT ATOMS ARE TOO CLOSE TO ',
     &               'ATOMIC CUBES'
        SPLRAT2= SPLRAT**2
        DO 350 IC=1,NNUC
         BOXD2= SIDE(2,1,IC)**2
         ICHANGE= 0
         DO JC=1,NNUC
          IF (IC .NE. JC) THEN
           RCOMP2= 0.0D0
           DO I=1,3
            IF (CUBE(I,JC) .LT. CUBE(I,IC)-SIDE(2,1,IC)) THEN
             RCOMP2= RCOMP2+(CUBE(I,JC)-(CUBE(I,IC)-SIDE(2,1,IC)))**2
            END IF
            IF (CUBE(I,JC) .GT. CUBE(I,IC)+SIDE(2,1,IC)) THEN
             RCOMP2= RCOMP2+(CUBE(I,JC)-(CUBE(I,IC)+SIDE(2,1,IC)))**2
            END IF
           END DO
           RCOMP2= RCOMP2*SPLRAT2
           IF (RCOMP2 .LT. BOXD2) THEN
            BOXD2= RCOMP2
            ICHANGE= 1
           END IF
          END IF
         END DO
C
C IF NECESSARY, REPLACE CUBE BY SMALLER CUBE AND INTERSTITIAL BOXES
C
         IF (ICHANGE .NE. 0) THEN
          JC=0
          DO KC=1,NUNIQUE
           BOXDM=ABS(CUBE(1,IC)-RNEWIDT(1,KC))
     &          +ABS(CUBE(2,IC)-RNEWIDT(2,KC))
     &          +ABS(CUBE(3,IC)-RNEWIDT(3,KC))
           IF (BOXDM .LE. TOLER) JC=KC
          END DO
          BOXDM=SQRT(BOXD2)
          IF (JC.NE.0) THEN
           PRINT '(A,I5,2(A,F12.6))','UNIQUE ATOM ',JC,
     &           ': OLD BOX: ',2*SIDE(2,1,IC),', NEW BOX: ',2*BOXDM
          END IF
          IF (NCUBE+26 .GT. MXCUBE) THEN
           write(6,*)'MXCUBE MUST BE AT LEAST: ',NCUBE+26
           CALL STOPIT
          ENDIF
          XSEP(1)=  SIDE(1,1,IC)
          XSEP(2)= -BOXDM
          XSEP(3)=  BOXDM
          XSEP(4)=  SIDE(2,1,IC)
          DO IX= -1,1
           DO IY= -1,1
            DO IZ= -1,1
             IF ((IX .EQ. 0) .AND. (IY .EQ. 0) .AND. (IZ .EQ. 0)) THEN
              JC=IC
             ELSE
              NCUBE=NCUBE+1
              JC=NCUBE
              NORIG(JC)=0
             END IF
             SIDE(1,1,JC)= -(XSEP(IX+3)-XSEP(IX+2))*0.5D0
             SIDE(2,1,JC)=  (XSEP(IX+3)-XSEP(IX+2))*0.5D0
             SIDE(1,2,JC)= -(XSEP(IY+3)-XSEP(IY+2))*0.5D0
             SIDE(2,2,JC)=  (XSEP(IY+3)-XSEP(IY+2))*0.5D0
             SIDE(1,3,JC)= -(XSEP(IZ+3)-XSEP(IZ+2))*0.5D0
             SIDE(2,3,JC)=  (XSEP(IZ+3)-XSEP(IZ+2))*0.5D0
             IF (JC .NE. IC) THEN
              CUBE(1,JC)=CUBE(1,IC)+(XSEP(IX+2)+XSEP(IX+3))*0.5D0
              CUBE(2,JC)=CUBE(2,IC)+(XSEP(IY+2)+XSEP(IY+3))*0.5D0
              CUBE(3,JC)=CUBE(3,IC)+(XSEP(IZ+2)+XSEP(IZ+3))*0.5D0
             END IF
            END DO
           END DO
          END DO
         END IF
  350   CONTINUE
C
C CHECK VOLUME AGAIN
C
        VOL=0.0D0
        DO IC=1,NCUBE
         VOL=VOL+8*SIDE(2,1,IC)*SIDE(2,2,IC)*SIDE(2,3,IC)
         IF (DEBUG) THEN
          PRINT 5010,NORIG(IC),(CUBE(J,IC),J=1,3),
     &               ((SIDE(K,J,IC),K=1,2),J=1,3)
 5010     FORMAT(' ',I5,3F10.3,4X,3(2F10.3,2X))
         END IF
        END DO
        IF (ABS(VOL-VOLUM) .GT. VOLTL*VOLUM) THEN
         write(6,*)'VMESH: ERROR IN SUBDIVISION'
         CALL STOPIT
        END IF
C
C LETS GET RID OF THOSE REALLY TINY CUBES FIRST
C
        VOLUM=0.0D0
        KCUBE=0
        DO 370 ICUBE=1,NCUBE
         VCUB=8*SIDE(2,1,ICUBE)*SIDE(2,2,ICUBE)*SIDE(2,3,ICUBE)
         IF (VCUB.GT.VOLTL) THEN
          KCUBE=KCUBE+1
          DO I=1,3
           CUBE(I,KCUBE)=CUBE(I,ICUBE)
           SIDE(1,I,KCUBE)=SIDE(1,I,ICUBE)
           SIDE(2,I,KCUBE)=SIDE(2,I,ICUBE)
          END DO
          RSQVOL(1,KCUBE)=
     &     CUBE(1,KCUBE)**2+CUBE(2,KCUBE)**2+CUBE(3,KCUBE)**2
          RSQVOL(2,KCUBE)=VCUB
          VOLUM=VOLUM+VCUB
         END IF
  370   CONTINUE
        NCUBE=KCUBE
C
C PRINT PARAMETERS OF CURRENT BOX SET
C
        IF (DEBUG) THEN
         write(6,*)' '
         write(6,*)'CURRENT BOX PARAMETERS(3):'
         DO ICUBE=1,NCUBE
          PRINT 8050,'BOX',ICUBE
          PRINT 8010,'CENTER',(CUBE(I,ICUBE), I=1,3)
          PRINT 8010,'LEFT  ',(SIDE(1,I,ICUBE), I=1,3)
          PRINT 8010,'RIGHT ',(SIDE(2,I,ICUBE), I=1,3)
         END DO
         PRINT 8040,'TOTAL VOLUME:',VOLUM,'EXPECTED:',EXPECTED
        END IF
C
C NOW PURGE OUT THE REDUNDANCIES AND KEEP TRACK OF MULTIPLICITIES FOR
C EACH IDENTITY CUBE. ASSIGN MULTIPLICITIES TO NUMBOX.
C
        PRINT '(A)','REMOVING SYMMETRY-EQUIVALENT BOXES'
        DO ICUBE=1,NCUBE
         NUMBOX(ICUBE)=0
        END DO
        DO 400 ICUBE=1,NCUBE
         IF (RSQVOL(2,ICUBE) .GE. 0.0D0) THEN
          CALL GASITES
     &     (1,CUBE(1,ICUBE),NUMBOX(ICUBE),RIDENT,MSITES)
          IFOUND=1
          DO 390 JCUBE=ICUBE+1,NCUBE
           IF ((ABS(RSQVOL(1,ICUBE)-RSQVOL(1,JCUBE)).LE.TOLER) .AND.
     &         (ABS(RSQVOL(2,ICUBE)-RSQVOL(2,JCUBE)).LE.TOLER)) THEN
C
C CHECK IF THIS CUBE IS EQUAL TO ONE OF THOSE GENERATED
C
            DO 380 KCUBE=1,NUMBOX(ICUBE)
             ERROR=ABS(CUBE(1,JCUBE)-RIDENT(1,KCUBE))+
     &             ABS(CUBE(2,JCUBE)-RIDENT(2,KCUBE))+
     &             ABS(CUBE(3,JCUBE)-RIDENT(3,KCUBE))
             IF (ERROR.LE.TOLER) THEN
              IFOUND=IFOUND+1
              RSQVOL(2,JCUBE)= -1.0D30
             END IF
  380       CONTINUE
           END IF
  390     CONTINUE
          IF (DEBUG) write(6,*)'ANTICIPATED NUMBER OF CUBES:'
     &                      ,NUMBOX(ICUBE),' FOUND: ',IFOUND
C
C IF WE DID NOT FIND ALL CUBES, PRINT OUT THE MESS AND STOP
C
          IF (IFOUND.NE.NUMBOX(ICUBE)) THEN
           write(6,*)'ERROR IN VMESH'
           write(6,*)'IFOUND= ',IFOUND,' EXPECTED ',NUMBOX(ICUBE)
           write(6,*)'ICUBE=  ',ICUBE,' NCUBE= ',NCUBE
           write(6,*)'VMESH: IFOUND AND NUMBOX ARE NOT EQUAL'
           CALL STOPIT
          END IF
         END IF
  400   CONTINUE
C
C ERASE ALL BOXES THAT ARE EQIVALENT DUE TO SYMMETRY
C
        KCUBE=0
        NATOM=0
        VOLUM=0.0D0
        DO 410 ICUBE=1,NCUBE
         IF (RSQVOL(2,ICUBE) .GT. 0.0D0) THEN
          KCUBE=KCUBE+1
          NUMBOX(KCUBE)=NUMBOX(ICUBE)
          IF (ICUBE.LE.NNUC) THEN
           NATOM=NATOM+1
           NORIG(KCUBE)=NORIG(ICUBE)
          END IF
          DO J=1,3
           CUBE(J,KCUBE)=CUBE(J,ICUBE)
           SIDE(1,J,KCUBE)=SIDE(1,J,ICUBE)
           SIDE(2,J,KCUBE)=SIDE(2,J,ICUBE)
          END DO
          VCUB=8*SIDE(2,1,KCUBE)*SIDE(2,2,KCUBE)*SIDE(2,3,KCUBE)
          VOLUM=VOLUM+VCUB*NUMBOX(KCUBE)
         END IF
  410   CONTINUE
        NCUBE=KCUBE
        IF (NATOM .NE. NUNIQUE) THEN
         write(6,*)'VMESH: NATOM <--> NUNIQUE INCONSISTENCY'
         CALL STOPIT
        END IF
C
C PRINT SURVIVING BOXES
C
        IF (DEBUG) THEN
         write(6,*)' '
         write(6,*)'INEQUIVALENT BOXES:'
         DO ICUBE=1,NCUBE
          PRINT 8050,'BOX',ICUBE,'MULTIPLICITY:',NUMBOX(ICUBE)
          PRINT 8010,'CENTER',(CUBE(I,ICUBE), I=1,3)
          PRINT 8010,'LEFT  ',(SIDE(1,I,ICUBE), I=1,3)
          PRINT 8010,'RIGHT ',(SIDE(2,I,ICUBE), I=1,3)
         END DO
         PRINT 8040,'TOTAL VOLUME:',VOLUM,'EXPECTED:',EXPECTED
        END IF
C
C TRY TO SLICE INTERSTITIAL BOXES WHICH TRANSFORM INTO THEMSELVES.
C WE NEED TO MAKE SURE THAT ARRAY CUBE IS LARGE ENOUGH.
C
        PRINT '(A)','CHECKING FOR REDUCIBLE BOXES'
        NTOTAL=NCUBE
  420   CONTINUE
         OK=.TRUE.
         NCUBE=NTOTAL
         DO 480 ICUBE=NUNIQUE+1,NCUBE
          NCREAT=0
          IF ((NTOTAL+8).GT.MXCUBE) THEN
           write(6,*)'VMESH: MXCUBE MUST BE AT LEAST: ',NTOTAL+8
           CALL STOPIT
          END IF
C
C FIND GROUP OPERATIONS THAT LEAVE CENTER OF CUBE UNCHANGED
C
          NTRAF=0
          DO 430 IGRP=1,NGPERM
           DIF=0.0D0
           DO J=1,3
            RTMP=0.0D0
            DO K=1,3
             RTMP=RTMP+RMAT(K,J,IGRP)*CUBE(K,ICUBE)
            END DO
            DIF=DIF+ABS(RTMP-CUBE(J,ICUBE))
           END DO
           IF (DIF.LT.TOLER) THEN
            NTRAF=NTRAF+1
            NSYMOP(NTRAF)=IGRP
           END IF
  430     CONTINUE
C
C IF WE FIND MORE THAN ONE SYMMETRY OPERATION, TRY DIFFERENT
C POSSIBILITIES OF SLICING. STORE BOX SIZE IN WRAD.
C INITIALIZE NXPT
C
          IF (NTRAF.GE.2) THEN
           GAIN=1.0D0
           DO 470 ITRY=1,7
            IM1=MOD((ITRY-1),3)+1
            II1=MIN(((ITRY+2)/3),2)
            II2=MOD(II1,2)+1
            IF (ITRY.EQ.7) II2=II1
            DO I=1,3
             NXPT(I)=II1
            END DO
            NXPT(IM1)=II2
C
C SLICE INTO AT MOST EIGHT BOXES
C
            DO IC=1,3
             IF (NXPT(IC).EQ.1) THEN
              RRAD(IC)= SIDE(2,IC,ICUBE)
              BOX(1,IC)=CUBE(IC,ICUBE)
             ELSE
              RRAD(IC)= 0.5D0*SIDE(2,IC,ICUBE)
              BOX(1,IC)=CUBE(IC,ICUBE)-0.5D0*SIDE(2,IC,ICUBE)
              BOX(2,IC)=CUBE(IC,ICUBE)+0.5D0*SIDE(2,IC,ICUBE)
             END IF
            END DO
            NADD=0
            DO IX=1,NXPT(1)
             DO IY=1,NXPT(2)
              DO IZ=1,NXPT(3)
               NADD=NADD+1
               BCUT(1,NADD)=BOX(IX,1)
               BCUT(2,NADD)=BOX(IY,2)
               BCUT(3,NADD)=BOX(IZ,3)
              END DO
             END DO
            END DO
C
C CHECK WHICH OF THESE BOXES ARE EQUIVALENT TO EACH OTHER
C USE NFBUF AS INDICATOR WHETHER THIS BOX HAS ALREADY BEEN FOUND
C
            DO IBX=1,NADD
             NFBUF(IBX)=1
            END DO
            NFOUND=0
            DO 460 IBX=1,NADD
             IF (NFBUF(IBX).NE.0) THEN
              NFOUND=NFOUND+1
              DO 450 JBX=IBX+1,NADD
               IF (NFBUF(JBX).NE.0) THEN
                DO 440 ITRAF=1,NTRAF
                 IGRP=NSYMOP(ITRAF)
                 DIF=0.0D0
                 DO J=1,3
                  RTMP=0.0D0
                  DO K=1,3
                   RTMP=RTMP+RMAT(K,J,IGRP)*BCUT(K,IBX)
                  END DO
                  DIF=DIF+ABS(RTMP-BCUT(J,JBX))
                 END DO
                 IF (DIF.LT.TOLER) NFBUF(JBX)=0
  440           CONTINUE
                IF (NFBUF(JBX).EQ.0) NFBUF(IBX)=NFBUF(IBX)+1
               END IF
  450         CONTINUE
             END IF
  460       CONTINUE
C
C CHECK IF THE RESULT IS USEFUL. IF YES, PUT THE CANDIDATE
C CUBES AT THE END OF ARRAY CUBE
C
            RATIO=NFOUND
            RATIO=NADD/RATIO
            IF ((GAIN+TOLER).LT.RATIO) THEN
             GAIN=RATIO
             NCREAT=0
             DO IBX=1,NADD
              IF (NFBUF(IBX).NE.0) THEN
               NCREAT=NCREAT+1
               NUMBOX(NTOTAL+NCREAT)=NFBUF(IBX)*NUMBOX(ICUBE)
               DO I=1,3
                CUBE(I,NTOTAL+NCREAT)=BCUT(I,IBX)
                SIDE(1,I,NTOTAL+NCREAT)= -RRAD(I)
                SIDE(2,I,NTOTAL+NCREAT)=  RRAD(I)
               END DO
              END IF
             END DO
            END IF
  470      CONTINUE
          END IF
C
C CHECK IF WE REALLY WANT TO SPLIT THAT PARTICULAR BOX
C FIND DISTANCE TO CLOSEST ATOM
C
          IF (NCREAT.NE.0) THEN
           DCLOS=1.0D30
           DO INUC=1,NNUC
            DIST=0.0D0
            DO I=1,3
             XXX=RNUC(I,INUC)
             XLEFT= CUBE(I,ICUBE)-SIDE(2,I,ICUBE)
             XRIGHT=CUBE(I,ICUBE)+SIDE(2,I,ICUBE)
             IF (RNUC(I,INUC).LT.XLEFT)  XXX=XLEFT
             IF (RNUC(I,INUC).GT.XRIGHT) XXX=XRIGHT
             DIST=DIST+(RNUC(I,INUC)-XXX)**2
            END DO
            DCLOS=MIN(DCLOS,DIST)
           END DO
           DALLOW=CUTFAC*DIST
C
C CHECK IF THE BOX IS LARGER THAN DALLOW IN ONE OR MORE
C DIMENSIONS. IF YES, CHECK IF THE PROPOSED CUT WILL ACTUALLY
C CHANGE THE CORRESPONDING COMPONENT OF THE BOX SIZE.
C
           FIXIT=.FALSE.
           DO IC=1,3
            XXX=SIDE(2,IC,ICUBE)
            IF (XXX.GT.DALLOW) THEN
             IF (ABS(XXX-SIDE(2,IC,NTOTAL+1)).GT.TOLER) FIXIT=.TRUE.
            END IF
           END DO
           IF (NCREAT.EQ.1) FIXIT=.TRUE.
C
C MOVE NEW BOXES TO THE RIGHT LOCATION
C
           IF (FIXIT) THEN
            OK=.FALSE.
            IF (DEBUG) write(6,*)'CUTTING BOX ',ICUBE,', GAIN= ',GAIN
            NUMBOX(ICUBE)=NUMBOX(NTOTAL+NCREAT)
            DO I=1,3
             CUBE(I,ICUBE)=CUBE(I,NTOTAL+NCREAT)
             SIDE(1,I,ICUBE)=SIDE(1,I,NTOTAL+NCREAT)
             SIDE(2,I,ICUBE)=SIDE(2,I,NTOTAL+NCREAT)
            END DO
            NTOTAL=NTOTAL+NCREAT-1
           END IF
          END IF
  480    CONTINUE
         IF (.NOT.OK) GOTO 420
        CONTINUE
        NCUBE=NTOTAL
C
C ZERO NORIG FOR INTERSTITIALS (ONLY FOR PRINTING PURPOSES)
C
        DO ICUBE=NUNIQUE+1,NCUBE
         NORIG(ICUBE)=0
        END DO
C
C PRINT FINAL BOX SET, DETERMINE CLOSEST ATOM FOR EACH INTERSTITIAL BOX
C
        PRINT '(A)',' '
        PRINT '(A)','FINAL BOX SET:'
        VOLUM=0.0D0
        VLDAM=0.0D0
        DCLOS=1.0D30
        DO ICUBE=1,NCUBE
         PRINT 1030,ICUBE,NUMBOX(ICUBE),NORIG(ICUBE)
         PRINT 1040,'CENTER',(CUBE(I,ICUBE),     I=1,3)
         PRINT 1040,'SIZE  ',(2*SIDE(2,I,ICUBE), I=1,3)
 1030    FORMAT('BOX ',I5,', MULTIPLICITY: ',I3,
     &          ', IDENTITY MEMBER: ',I3)
 1040    FORMAT(A,3(1X,F12.6))
         VBOX=8*SIDE(2,1,ICUBE)*SIDE(2,2,ICUBE)*SIDE(2,3,ICUBE)
         VOLUM=VOLUM+NUMBOX(ICUBE)*VBOX
         IF (NORIG(ICUBE) .EQ. 0) THEN
          VLDA=0.0D0
          DO INUC=1,NNUC
           DIST= 0.0D0
           DO IC=1,3
            X1= CUBE(IC,ICUBE)-SIDE(2,IC,ICUBE)
            X2= CUBE(IC,ICUBE)+SIDE(2,IC,ICUBE)
            IF (RNUC(IC,INUC) .LT. X1) THEN
             DIST= DIST+(RNUC(IC,INUC)-X1)**2
            END IF
            IF (RNUC(IC,INUC) .GT. X2) THEN
             DIST= DIST+(RNUC(IC,INUC)-X2)**2
            END IF
           END DO
           SDIST= SQRT(DIST)
           CALL RPFIT(IFNU(INUC),SDIST,1.0D0/SDIST,RHOF,POTF)
           VLDA= MIN(VLDA,POTF)
          END DO
          PRINT 1040,'V(LDA)',VLDA
          VLDAM=MIN(VLDAM,VLDA)
         END IF
        END DO
        PRINT 1050,VLDAM
 1050   FORMAT('LOWEST LDA POTENTIAL FOR INTERSTITIAL REGIONS: ',F12.5)
        PRINT 1060,VOLUM,EXPECTED
 1060   FORMAT('TOTAL VOLUME: ',D20.12,', CORRECT: ',D20.12)
C
C START FILLING CUBES UP WITH MESH POINTS. FIRST THE ATOMIC CUBES.
C WE NEED:  * ONE SPHERE MESH FROM 0 TO RSPH PER IDENTITY MEMBER
C           * ONE SPHERE MESH FROM RSPH TO RBOX PER UNIQUE ATOM
C           * EXCLUDED REGION MESH PER UNIQUE ATOM (BOX SIZE RBOX)
C
C SET NGRP BACK TO NGFULL.
C LOOP OVER ALL IDENTITY MEMBERS. GET MINIMUM SPHERE RADIUS RSPH.
C
        PRINT '(A)',' '
        PRINT '(A)','ASSIGNING POINTS TO CUBES THAT CONTAIN ATOMS'
        NGRP=NGFULL
        NMSH=0
        DO 550 IIDENT=1,NIDENT
         NDEG=0
         RSPH=1.0D30
         VINNER=0.0D0
         DO IATOM=1,NUNIQUE
          IF (NORIG(IATOM).EQ.IIDENT) THEN
           NDEG=NDEG+NUMBOX(IATOM)
           RSPH=MIN(RSPH,SIDE(2,1,IATOM))
          END IF
         END DO
         IF (NDEG.EQ.0) GOTO 550
         IF (DEBUG) THEN
          write(6,*)' '
          write(6,*)'IDENTITY MEMBER ',IIDENT,
     &           ' MULTIPLICITY: ',NDEG
         END IF
         ERRSPH=ERRAT
         ZAT= ABS(ZNUC(IFUIDT(IIDENT)))
         NZ= NINT(ZAT)
         CALL RPFIT(IFUIDT(IIDENT),RSPH,1.0D0/RSPH,RHOF,PSPH)
         PSPH= ABS(PSPH)
         IF (NZ .GE. 1) ERRSPH=ERRSPH/NZ
         IF (LSYWT) ERRSPH=ERRAT/NDEG
         IFOUND=0
C
C LOOP OVER ALL UNIQUE ATOMS
C
         DO 540 IATOM=1,NUNIQUE
          IF (NORIG(IATOM).EQ.IIDENT) THEN
           IF (DEBUG) THEN
            write(6,*)' '
            write(6,*)'UNIQUE ATOM     ',IATOM, 
     &             ' MULTIPLICITY: ',NUMBOX(IATOM)
           END IF
           IFOUND=IFOUND+1
C
C GET ATOM TYPE
C
           ITYP=NTYP
           DO JTYP=NTYP-1, 1, -1
            IF (ZAT.LE.ZZON(JTYP)) ITYP=JTYP
           END DO
C
C SETUP INPUT FOR FLACUB AND CALL FLACUB
C RADIAL POINTS HAVE TO BE IN RBUF(1,I)
C
           RBOX=SIDE(2,1,IATOM)
           ERRBOX=ERRAT
           IF (PSPH .GT. 1.0D0) ERRBOX=ERRBOX/PSPH
           IF (LSYWT) ERRBOX=ERRBOX/NUMBOX(IATOM)
           AMAX=ALMAX(IIDENT)
           NPOLY=NPATS(ITYP)
           IF (DEBUG) THEN
            PRINT 8040,'Z:',ZAT,'RADIUS:',RBOX
            write(6,*)'CALLING FLACUB'
           END IF
           CALL FLACUB(MXCPTS,NR1,NR2,NCTOT,RBUF,WBUF,NPHI(ITYP),
     &                 NTHET(ITYP),RSPH,RBOX,ERRSPH,ERRBOX,2*ALONG,
     &                 AMAX,AFUDAT,NPOLY)
           NRAD=NR1+NR2
           IF (DEBUG) THEN
            write(6,*)'AFTER FLACUB: NMSH= ',NCTOT,
     &              ' NR1= ',NR1,' NR2= ',NR2
           END IF
           IF (NRAD.GT.MXRAD) THEN
            write(6,*)'VMESH: MXRAD MUST BE AT LEAST: ',NRAD
            CALL STOPIT
           END IF
C
C TEST VOLUME AND RENORMALIZE RADIAL WEIGHTS
C
           VOLUM=0.0D0
           ATMP=1.0D0/(4*PI)
           DO IPTS=1,NRAD
            VOLUM=VOLUM+WBUF(IPTS)
            WBUF(IPTS)=WBUF(IPTS)*ATMP
           END DO
           DO IPTS=NRAD+1,NCTOT
            VOLUM=VOLUM+48*WBUF(IPTS)
           END DO
           EXACT=8*RBOX**3
           IF (DEBUG) PRINT 8040,'CUBE VOLUME:',VOLUM,'EXACT:',EXACT
C
C ADD RADIAL POINTS. IF (IFOUND.EQ.1), WE HAVE TO ADD THE MESH FOR
C THE INNER SPHERE FROM 0 TO RSPH. NOTE THAT IN THIS CASE NGRP=NFULL
C IS NECESSARY WHILE FOR THE OTHER RADIAL MESH NGRP=NGPERM IS CORRECT.
C
           IF (DEBUG) THEN
            write(6,*)' '
            write(6,*)'ADDING RADIAL + ANGULAR POINTS'
           END IF
           MSTART=2
           IF (IFOUND.EQ.1) MSTART=1
           DO 510 IMESH=MSTART,2
            IF (IMESH.EQ.1) THEN
             NGRP=NGFULL
             NSITES=NDEG
             ISTART=1
             IEND=NR1
            ELSE
             NGRP=NGPERM
             NSITES=NUMBOX(IATOM)
             ISTART=NR1+1
             IEND=NR1+NR2
            END IF
            NSAVP=NMSH
C
C FOR EACH ZONE, FIND ASSOCIATED RADIAL POINTS
C
            DO 500 IRZ=1,NRZONE
             IR=0
             DO JR=ISTART,IEND
              IF (RBUF(1,JR).LT.RZON(IRZ)) THEN
               IR=IR+1
               RRAD(JR-ISTART+1)=RBUF(1,JR)
               WRAD(JR-ISTART+1)=WBUF(JR)
              ELSE
               GOTO 490
              END IF
             END DO
  490        CONTINUE
             ISTART=ISTART+IR
             IF (IR.EQ.0) GOTO 500
C
C GET ANGULAR MESH AND CALL ADDPTS
C
             CALL ANGMSH(MXANG,LMXA(IRZ,ITYP),IANP,ANGLE,DOMEGA)
             IF (DEBUG) THEN
              write(6,*)'IATOM: ',IATOM,' RAD/ANG MESH ',IMESH,IRZ
              PRINT 8010,'CENTER:',(CUBE(K,IATOM),K=1,3)
             END IF
             CALL ADDPTS(NSITES,CUBE(1,IATOM),RRAD,WRAD,ANGLE,DOMEGA,
     &                   IR,IANP)
  500       CONTINUE
C
C GET NUMERICAL VALUE OF SPHERE VOLUME
C
            IF (DEBUG) write(6,*)'SPHERE FILLED, NMSH= ',NMSH
            IF (NMSH.GT.MAX_PTS) THEN
             write(6,*)'VMESH: MAX_PTS MUST BE AT LEAST: ',NMSH
             CALL STOPIT
            END IF
            VOLSPH=0.0D0
            DO IPTS=NSAVP+1,NMSH
             VOLSPH=VOLSPH+WMSH(IPTS)
            END DO
            ATMP=NSITES
            VOLSPH=VOLSPH/ATMP
            IF (IMESH.EQ.1) VINNER=VOLSPH
  510      CONTINUE
           CORSPH=(4*PI/3.0D0)*RBOX**3
           IF (DEBUG) THEN
            PRINT 8040,'VSPHERE:',VOLSPH+VINNER,'CORRECT:',CORSPH
           END IF
C
C THE SPHERES ARE DONE.
C NOW THE PART OUTSIDE THE SPHERE BUT INSIDE THE CUBE
C GET ALL 48 POINTS
C
           IF (DEBUG) THEN
            write(6,*)' '
            write(6,*)'ADDING POINTS FOR EXCLUDED CUBIC REGION'
           END IF
           NSAVP=NMSH
           DO 530 IPTS=NRAD+1,NCTOT
            RRAD(1)=1.0D0
            WRAD(1)=WBUF(IPTS)
            XXX=RBUF(1,IPTS)
            YYY=RBUF(2,IPTS)
            ZZZ=RBUF(3,IPTS)
            IANP=0
            DO 520 IX=1,2
             XXX= -XXX
             DO IY=1,2
              YYY= -YYY
              DO IZ=1,2
               ZZZ= -ZZZ
               DO ISW=1,2
                ATMP=XXX
                XXX= YYY
                YYY= ATMP
                DO IPM=1,3
                 IANP=IANP+1
                 ATMP=ZZZ
                 ZZZ= YYY
                 YYY= XXX
                 XXX= ATMP
                 ANGLE(1,IANP)=XXX
                 ANGLE(2,IANP)=YYY
                 ANGLE(3,IANP)=ZZZ
                 DOMEGA(IANP)=1.0D0
                END DO
               END DO
              END DO
             END DO
  520       CONTINUE
            CALL ADDPTS(NSITES,CUBE(1,IATOM),RRAD,WRAD,
     &                  ANGLE,DOMEGA,1,48)
  530      CONTINUE
C
C GET NUMERICAL VALUE FOR EXCLUDED VOLUME
C
           IF (NMSH.GT.MAX_PTS) THEN
            write(6,*)'VMESH: MAX_PTS MUST BE AT LEAST: ',NMSH
            CALL STOPIT
           END IF
           VEXCL=0.0D0
           DO IPTS=NSAVP+1,NMSH
            VEXCL=VEXCL+WMSH(IPTS)
           END DO
           ATMP=NSITES
           VEXCL=VEXCL/ATMP
           COREX=(8-(4*PI/3.0D0))*RBOX**3
           IF (DEBUG) THEN
            write(6,*)'AFTER EXCLUDED CUBIC REGION, NMSH= ',NMSH
            PRINT 8040,'VEXCL:',VEXCL,'CORRECT:',COREX
           END IF
          END IF
  540    CONTINUE
  550   CONTINUE
        PRINT '(A,I10)','NUMBER OF POINTS FOR ATOMIC CUBES: ',NMSH
C
C ADD THE INTERSTITIAL POINTS
C
        PRINT '(A)','ASSIGNING POINTS TO INTERSTITIAL BOXES'
c
c send information about atomic properties to workers
c set npts=0 for workers
c
#ifdef MPI
c
        CALL SENDDATA(106)
c
#endif
c
C LOOP OVER ALL ORIGINAL CUBES. SET BACK NGRP FIRST.
C
        NGRP=NGFULL
        DO IBOX=NUNIQUE+1,NCUBE
         DO IC=1,3
          BOX(1,IC)= -SIDE(2,IC,IBOX)+CUBE(IC,IBOX)
          BOX(2,IC)=  SIDE(2,IC,IBOX)+CUBE(IC,IBOX)
         END DO
         ERRBOX=ERRIS
         IF (LSYWT) ERRBOX=ERRBOX/NUMBOX(IBOX)
c
#ifdef MPI
c
         IF ((NPROC .LT. MSHSLV) .OR. (NPROC .LE. 0)) THEN
          CALL CKWORKER(1,NTID)
          IF (NCALLED .NE. NPROC) THEN
           CALL PAMMESH(1,BOX,ERRBOX,NUMBOX(IBOX))
          ELSE
           CALL FILLIST(BOX,ERRBOX,NUMBOX(IBOX))
          END IF
         ELSE
          CALL CKWORKER(2,NTID) 
          CALL PAMMESH(1,BOX,ERRBOX,NUMBOX(IBOX))
         ENDIF
c
#else
c
         CALL FILLIST(BOX,ERRBOX,NUMBOX(IBOX))
c
#endif
c
         IF (MOD(IBOX,10) .EQ. 0) THEN
          PRINT '(A,I8,A,I8,A)','BOX ',IBOX,' OF ',NCUBE,' ...'
         END IF
        END DO
c
c get mesh points from workers
c
#ifdef MPI
c
        CALL PAMMESH(2,BOX,0.0D0,0)
c
#endif
c
        PRINT '(A,I10)','TOTAL NUMBER OF MESH POINTS:       ',NMSH
C
C REORDER MESH POINTS
C
        PRINT '(A)','REORDERING MESH POINTS'
        CALL GTTIME(TIME2)
        CALL REORMSH
        CALL GTTIME(TIME3)
C
C CHECK INTEGRATED CHARGE FOR OVERLAPPING ATOMIC DENSITIES
C
        PRINT '(A)',' '
        PRINT '(A)','TEST INTEGRATION FOR BARE GAUSSIANS'
        PRINT '(A)',' '
        PRINT '(2A)',' ID-MEM   BEST ALPHA   BEST ERROR   ',
     &               'WORST ALPHA  WORST ERROR'
        PRINT '(2A)','------------------------------------',
     &               '------------------------'
        AFUDGE=MAX(AFUDAT,AFUDIS)
        ACCU=0.01D0*MAX(ERRAT,ERRIS)
        ACCU= -LOG(ACCU)
        DO 820 IID=1,NIDENT
         CALL GASITES(1,RIDT(1,IID),NEQV,CUBE,MSITES)
         AMIN=ALONG+ALMIN(IID)
         AMAX=ALMAX(IID)
         AMAX=MAX(AMAX,AMIN)
         NALTST=2+NINT(LOG(AMAX/AMIN)/LOG(AFUDGE))
         ATMP=NALTST-1
         BETA=(AMAX/AMIN)**(1.0D0/ATMP)
         EBST=1.0D30
         EWST=0.0D00
         ALBS=0.0D0
         ALWS=0.0D0
         ALP=AMIN
         DO 810 IALP=1,NALTST
          SUM=0.0D0
          RCUTS=ACCU/ALP
          DO INUC=1,NEQV
           DO IPTS=1,NMSH
            RTMP=(RMSH(1,IPTS)-CUBE(1,INUC))**2
     &          +(RMSH(2,IPTS)-CUBE(2,INUC))**2
     &          +(RMSH(3,IPTS)-CUBE(3,INUC))**2
            IF (RTMP .LT. RCUTS) THEN
             SUM=SUM+WMSH(IPTS)*EXP(-ALP*RTMP)
            END IF
           END DO
          END DO
          SUM=SUM/NEQV
          ERROR=ABS((ALP/PI)**1.5D0 * SUM - 1.0D0)
          IF (ERROR .GT. EWST) THEN
           EWST=ERROR
           ALWS=ALP
          END IF
          IF (ERROR .LT. EBST) THEN
           EBST=ERROR
           ALBS=ALP
          END IF
          ALP=ALP*BETA
  810    CONTINUE
         PRINT 1070,IID,ALBS,EBST,ALWS,EWST
 1070    FORMAT(I5,2(2X,E12.2,1X,E12.2))
  820   CONTINUE
        PRINT '(A)',' '
c
c mpi: send mesh to all nodes
c
#ifdef MPI
c
        CALL SENDDATA(102)
c
#endif
c
C
C TEST MESH
C
! testing: doesn't work with FODONMSH
!  -> Uncommented for Ham. mixing restart debug
        CALL TSTMSH
C
C WRITE VMOLD AND LEAVE
C
        OPEN(99,FILE='VMOLD',FORM='UNFORMATTED',STATUS='UNKNOWN')
        REWIND(99)
        WRITE(99)NMSH,ICALC
        WRITE(99)((RMSH(J,I),J=1,3),I=1,NMSH)
        WRITE(99)(WMSH(I),I=1,NMSH)
        CLOSE(99)
C
        deallocate(NPOW)
        deallocate(IFNU)
        deallocate(ZALP)
        deallocate(RNUC)
#ifdef MPI
c
        CALL SENDDATA(206)
c
#endif
C
C     --- DEALLOCATE LOCAL ARRAYS ---
C
      DEALLOCATE(BCUT,STAT=IERR)
      IF(IERR/=0)WRITE(6,*)'VMESH:ERROR DEALLOCATING BCUT'
      DEALLOCATE(PLANE,STAT=IERR)
      IF(IERR/=0)WRITE(6,*)'VMESH:ERROR DEALLOCATING PLANE'
      DEALLOCATE(SIDE,STAT=IERR)
      IF(IERR/=0)WRITE(6,*)'VMESH:ERROR DEALLOCATING SIDE'
      DEALLOCATE(XSLICE,STAT=IERR)
      IF(IERR/=0)WRITE(6,*)'VMESH:ERROR DEALLOCATING XSLICE'
      DEALLOCATE(XSEP,STAT=IERR)
      IF(IERR/=0)WRITE(6,*)'VMESH:ERROR DEALLOCATING XSEP'
      DEALLOCATE(RRAD,STAT=IERR)
      IF(IERR/=0)WRITE(6,*)'VMESH:ERROR DEALLOCATING RRAD'
      DEALLOCATE(WRAD,STAT=IERR)
      IF(IERR/=0)WRITE(6,*)'VMESH:ERROR DEALLOCATING WRAD'
      DEALLOCATE(RSQVOL,STAT=IERR)
      IF(IERR/=0)WRITE(6,*)'VMESH:ERROR DEALLOCATING RSQVOL'
      DEALLOCATE(BOXMOL,STAT=IERR)
      IF(IERR/=0)WRITE(6,*)'VMESH:ERROR DEALLOCATING BOXMOL'
      DEALLOCATE(ALMIN,STAT=IERR)
      IF(IERR/=0)WRITE(6,*)'VMESH:ERROR DEALLOCATING ALMIN'
      DEALLOCATE(ALMAX,STAT=IERR)
      IF(IERR/=0)WRITE(6,*)'VMESH:ERROR DEALLOCATING ALMAX'
      DEALLOCATE(ISLICE,STAT=IERR)
      IF(IERR/=0)WRITE(6,*)'VMESH:ERROR DEALLOCATING ISLICE'
      DEALLOCATE(NUMBOX,STAT=IERR)
      IF(IERR/=0)WRITE(6,*)'VMESH:ERROR DEALLOCATING NUMBOX'
      DEALLOCATE(NSYMOP,STAT=IERR)
      IF(IERR/=0)WRITE(6,*)'VMESH:ERROR DEALLOCATING NSYMOP'
      DEALLOCATE(NORIG,STAT=IERR)
      IF(IERR/=0)WRITE(6,*)'VMESH:ERROR DEALLOCATING NORIG'
      DEALLOCATE(CATOM,STAT=IERR)
      IF(IERR/=0)WRITE(6,*)'VMESH:ERROR DEALLOCATING CATOM'
      DEALLOCATE(IFSPL,STAT=IERR)
      IF(IERR/=0)WRITE(6,*)'VMESH:ERROR DEALLOCATING IFSPL'
C
C     --- GET TIMES AND PRINT ---
C
  900 CALL GTTIME(TIME4)
      CALL TIMOUT('CONSTRUCTION OF VARIATIONAL MESH:  ',TIME2-TIME1)
      CALL TIMOUT('MESH REORDERING:                   ',TIME3-TIME2)
      CALL TIMOUT('MESH READING / TESTING + WRITING:  ',TIME4-TIME3)
      RETURN
C
C     --- FORMAT STUFF ---
C
 8010 FORMAT(1X,A,3(1X,G15.8))
 8030 FORMAT(1X,A,1X,I5,2(1X,G15.8))
 8040 FORMAT(2(1X,A,1X,G20.14))
 8050 FORMAT(3(1X,A,1X,I6,1X))
 8060 FORMAT(3(1X,G20.14)/2(1X,G20.14))
 8070 FORMAT(1X,A,1X,I6,1X,A,1X,G20.14,1X,A,1X,I6)
C
C     ------------------------------------------------------------------
C
       END
